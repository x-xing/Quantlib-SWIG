# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package QuantLib;
use base qw(Exporter);
use base qw(DynaLoader);
package QuantLibc;
bootstrap QuantLib;
package QuantLib;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package QuantLib;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package QuantLib;

*transpose = *QuantLibc::transpose;
*outerProduct = *QuantLibc::outerProduct;
*pseudoSqrt = *QuantLibc::pseudoSqrt;
*nullInt = *QuantLibc::nullInt;
*nullDouble = *QuantLibc::nullDouble;
*Actual365NoLeap = *QuantLibc::Actual365NoLeap;
*as_iborindex = *QuantLibc::as_iborindex;
*as_gsr_process = *QuantLibc::as_gsr_process;
*as_coupon = *QuantLibc::as_coupon;
*as_fixed_rate_coupon = *QuantLibc::as_fixed_rate_coupon;
*setCouponPricer = *QuantLibc::setCouponPricer;
*as_floating_rate_coupon = *QuantLibc::as_floating_rate_coupon;
*FixedRateLeg = *QuantLibc::FixedRateLeg;
*IborLeg = *QuantLibc::IborLeg;
*CmsLeg = *QuantLibc::CmsLeg;
*CmsZeroLeg = *QuantLibc::CmsZeroLeg;
*blackFormula = *QuantLibc::blackFormula;
*blackFormulaImpliedStdDev = *QuantLibc::blackFormulaImpliedStdDev;
*blackFormulaCashItmProbability = *QuantLibc::blackFormulaCashItmProbability;
*bachelierBlackFormula = *QuantLibc::bachelierBlackFormula;
*bachelierBlackFormulaImpliedVol = *QuantLibc::bachelierBlackFormulaImpliedVol;
*inflationBaseDate = *QuantLibc::inflationBaseDate;
*cleanPriceFromZSpread = *QuantLibc::cleanPriceFromZSpread;
*as_depositratehelper = *QuantLibc::as_depositratehelper;
*as_fraratehelper = *QuantLibc::as_fraratehelper;
*as_swapratehelper = *QuantLibc::as_swapratehelper;
*as_oisratehelper = *QuantLibc::as_oisratehelper;
*getCovariance = *QuantLibc::getCovariance;
*enableTracing = *QuantLibc::enableTracing;
*disableTracing = *QuantLibc::disableTracing;
*as_zerocurve = *QuantLibc::as_zerocurve;

############# Class : QuantLib::Period ##############

package QuantLib::Period;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*length = *QuantLibc::Period_length;
*units = *QuantLibc::Period_units;
*frequency = *QuantLibc::Period_frequency;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Period(@_);
    bless $self, $pkg if defined($self);
}

*to_string = *QuantLibc::Period_to_string;
*__repr__ = *QuantLibc::Period___repr__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Period($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PeriodVector ##############

package QuantLib::PeriodVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PeriodVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::PeriodVector_size;
*empty = *QuantLibc::PeriodVector_empty;
*clear = *QuantLibc::PeriodVector_clear;
*push = *QuantLibc::PeriodVector_push;
*pop = *QuantLibc::PeriodVector_pop;
*get = *QuantLibc::PeriodVector_get;
*set = *QuantLibc::PeriodVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PeriodVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Date ##############

package QuantLib::Date;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*weekday = *QuantLibc::Date_weekday;
*dayOfMonth = *QuantLibc::Date_dayOfMonth;
*dayOfYear = *QuantLibc::Date_dayOfYear;
*month = *QuantLibc::Date_month;
*year = *QuantLibc::Date_year;
*hours = *QuantLibc::Date_hours;
*minutes = *QuantLibc::Date_minutes;
*seconds = *QuantLibc::Date_seconds;
*milliseconds = *QuantLibc::Date_milliseconds;
*microseconds = *QuantLibc::Date_microseconds;
*fractionOfDay = *QuantLibc::Date_fractionOfDay;
*fractionOfSecond = *QuantLibc::Date_fractionOfSecond;
*serialNumber = *QuantLibc::Date_serialNumber;
*isLeap = *QuantLibc::Date_isLeap;
*minDate = *QuantLibc::Date_minDate;
*maxDate = *QuantLibc::Date_maxDate;
*todaysDate = *QuantLibc::Date_todaysDate;
*localDateTime = *QuantLibc::Date_localDateTime;
*universalDateTime = *QuantLibc::Date_universalDateTime;
*endOfMonth = *QuantLibc::Date_endOfMonth;
*isEndOfMonth = *QuantLibc::Date_isEndOfMonth;
*nextWeekday = *QuantLibc::Date_nextWeekday;
*nthWeekday = *QuantLibc::Date_nthWeekday;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Date(@_);
    bless $self, $pkg if defined($self);
}

*weekdayNumber = *QuantLibc::Date_weekdayNumber;
*to_string = *QuantLibc::Date_to_string;
*__repr__ = *QuantLibc::Date___repr__;
*ISO = *QuantLibc::Date_ISO;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Date($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DateParser ##############

package QuantLib::DateParser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*parseFormatted = *QuantLibc::DateParser_parseFormatted;
*parseISO = *QuantLibc::DateParser_parseISO;
*parse = *QuantLibc::DateParser_parse;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DateParser(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DateParser($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PeriodParser ##############

package QuantLib::PeriodParser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*parse = *QuantLibc::PeriodParser_parse;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PeriodParser(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PeriodParser($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DateVector ##############

package QuantLib::DateVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DateVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::DateVector_size;
*empty = *QuantLibc::DateVector_empty;
*clear = *QuantLibc::DateVector_clear;
*push = *QuantLibc::DateVector_push;
*pop = *QuantLibc::DateVector_pop;
*get = *QuantLibc::DateVector_get;
*set = *QuantLibc::DateVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DateVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IMM ##############

package QuantLib::IMM;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*F = *QuantLibc::IMM_F;
*G = *QuantLibc::IMM_G;
*H = *QuantLibc::IMM_H;
*J = *QuantLibc::IMM_J;
*K = *QuantLibc::IMM_K;
*M = *QuantLibc::IMM_M;
*N = *QuantLibc::IMM_N;
*Q = *QuantLibc::IMM_Q;
*U = *QuantLibc::IMM_U;
*V = *QuantLibc::IMM_V;
*X = *QuantLibc::IMM_X;
*Z = *QuantLibc::IMM_Z;
*isIMMdate = *QuantLibc::IMM_isIMMdate;
*isIMMcode = *QuantLibc::IMM_isIMMcode;
*code = *QuantLibc::IMM_code;
*date = *QuantLibc::IMM_date;
*nextDate = *QuantLibc::IMM_nextDate;
*nextCode = *QuantLibc::IMM_nextCode;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IMM(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IMM($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ASX ##############

package QuantLib::ASX;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*F = *QuantLibc::ASX_F;
*G = *QuantLibc::ASX_G;
*H = *QuantLibc::ASX_H;
*J = *QuantLibc::ASX_J;
*K = *QuantLibc::ASX_K;
*M = *QuantLibc::ASX_M;
*N = *QuantLibc::ASX_N;
*Q = *QuantLibc::ASX_Q;
*U = *QuantLibc::ASX_U;
*V = *QuantLibc::ASX_V;
*X = *QuantLibc::ASX_X;
*Z = *QuantLibc::ASX_Z;
*isASXdate = *QuantLibc::ASX_isASXdate;
*isASXcode = *QuantLibc::ASX_isASXcode;
*code = *QuantLibc::ASX_code;
*date = *QuantLibc::ASX_date;
*nextDate = *QuantLibc::ASX_nextDate;
*nextCode = *QuantLibc::ASX_nextCode;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ASX(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ASX($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IntVector ##############

package QuantLib::IntVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IntVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::IntVector_size;
*empty = *QuantLibc::IntVector_empty;
*clear = *QuantLibc::IntVector_clear;
*push = *QuantLibc::IntVector_push;
*pop = *QuantLibc::IntVector_pop;
*get = *QuantLibc::IntVector_get;
*set = *QuantLibc::IntVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IntVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::UnsignedIntVector ##############

package QuantLib::UnsignedIntVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_UnsignedIntVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::UnsignedIntVector_size;
*empty = *QuantLibc::UnsignedIntVector_empty;
*clear = *QuantLibc::UnsignedIntVector_clear;
*push = *QuantLibc::UnsignedIntVector_push;
*pop = *QuantLibc::UnsignedIntVector_pop;
*get = *QuantLibc::UnsignedIntVector_get;
*set = *QuantLibc::UnsignedIntVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_UnsignedIntVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DoubleVector ##############

package QuantLib::DoubleVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DoubleVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::DoubleVector_size;
*empty = *QuantLibc::DoubleVector_empty;
*clear = *QuantLibc::DoubleVector_clear;
*push = *QuantLibc::DoubleVector_push;
*pop = *QuantLibc::DoubleVector_pop;
*get = *QuantLibc::DoubleVector_get;
*set = *QuantLibc::DoubleVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DoubleVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::StrVector ##############

package QuantLib::StrVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_StrVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::StrVector_size;
*empty = *QuantLibc::StrVector_empty;
*clear = *QuantLibc::StrVector_clear;
*push = *QuantLibc::StrVector_push;
*pop = *QuantLibc::StrVector_pop;
*get = *QuantLibc::StrVector_get;
*set = *QuantLibc::StrVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_StrVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BoolVector ##############

package QuantLib::BoolVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BoolVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::BoolVector_size;
*empty = *QuantLibc::BoolVector_empty;
*clear = *QuantLibc::BoolVector_clear;
*push = *QuantLibc::BoolVector_push;
*pop = *QuantLibc::BoolVector_pop;
*get = *QuantLibc::BoolVector_get;
*set = *QuantLibc::BoolVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BoolVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NodePair ##############

package QuantLib::NodePair;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NodePair(@_);
    bless $self, $pkg if defined($self);
}

*swig_first_get = *QuantLibc::NodePair_first_get;
*swig_first_set = *QuantLibc::NodePair_first_set;
*swig_second_get = *QuantLibc::NodePair_second_get;
*swig_second_set = *QuantLibc::NodePair_second_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NodePair($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NodeVector ##############

package QuantLib::NodeVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NodeVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::NodeVector_size;
*empty = *QuantLibc::NodeVector_empty;
*clear = *QuantLibc::NodeVector_clear;
*push = *QuantLibc::NodeVector_push;
*pop = *QuantLibc::NodeVector_pop;
*get = *QuantLibc::NodeVector_get;
*set = *QuantLibc::NodeVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NodeVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Exercise ##############

package QuantLib::Exercise;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::Exercise___deref__;
*isNull = *QuantLibc::Exercise_isNull;
*American = *QuantLibc::Exercise_American;
*American = *QuantLibc::Exercise_American;
*Bermudan = *QuantLibc::Exercise_Bermudan;
*Bermudan = *QuantLibc::Exercise_Bermudan;
*European = *QuantLibc::Exercise_European;
*European = *QuantLibc::Exercise_European;
*exerciseType = *QuantLibc::Exercise_exerciseType;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Exercise(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Exercise($self);
        delete $OWNER{$self};
    }
}

*type = *QuantLibc::Exercise_type;
*dates = *QuantLibc::Exercise_dates;
*lastDate = *QuantLibc::Exercise_lastDate;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EuropeanExercise ##############

package QuantLib::EuropeanExercise;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Exercise QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EuropeanExercise(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EuropeanExercise($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AmericanExercise ##############

package QuantLib::AmericanExercise;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Exercise QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AmericanExercise(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AmericanExercise($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BermudanExercise ##############

package QuantLib::BermudanExercise;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Exercise QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BermudanExercise(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BermudanExercise($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RebatedExercise ##############

package QuantLib::RebatedExercise;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Exercise QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RebatedExercise(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RebatedExercise($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Observable ##############

package QuantLib::Observable;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::Observable___deref__;
*isNull = *QuantLibc::Observable_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Observable(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Observable($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Array ##############

package QuantLib::Array;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Array(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::Array_size;
*to_string = *QuantLibc::Array_to_string;
*get = *QuantLibc::Array_get;
*set = *QuantLibc::Array_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Array($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LexicographicalView ##############

package QuantLib::LexicographicalView;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*xSize = *QuantLibc::LexicographicalView_xSize;
*ySize = *QuantLibc::LexicographicalView_ySize;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LexicographicalView(@_);
    bless $self, $pkg if defined($self);
}

*to_string = *QuantLibc::LexicographicalView_to_string;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LexicographicalView($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Matrix ##############

package QuantLib::Matrix;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Matrix(@_);
    bless $self, $pkg if defined($self);
}

*rows = *QuantLibc::Matrix_rows;
*columns = *QuantLibc::Matrix_columns;
*to_string = *QuantLibc::Matrix_to_string;
*get = *QuantLibc::Matrix_get;
*set = *QuantLibc::Matrix_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Matrix($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SalvagingAlgorithm ##############

package QuantLib::SalvagingAlgorithm;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*None = *QuantLibc::SalvagingAlgorithm_None;
*Spectral = *QuantLibc::SalvagingAlgorithm_Spectral;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SalvagingAlgorithm(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SalvagingAlgorithm($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SVD ##############

package QuantLib::SVD;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SVD(@_);
    bless $self, $pkg if defined($self);
}

*U = *QuantLibc::SVD_U;
*V = *QuantLibc::SVD_V;
*S = *QuantLibc::SVD_S;
*singularValues = *QuantLibc::SVD_singularValues;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SVD($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Quote ##############

package QuantLib::Quote;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::Quote___deref__;
*isNull = *QuantLibc::Quote_isNull;
*asObservable = *QuantLibc::Quote_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Quote(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Quote($self);
        delete $OWNER{$self};
    }
}

*value = *QuantLibc::Quote_value;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::QuoteHandle ##############

package QuantLib::QuoteHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_QuoteHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::QuoteHandle___deref__;
*empty = *QuantLibc::QuoteHandle_empty;
*asObservable = *QuantLibc::QuoteHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_QuoteHandle($self);
        delete $OWNER{$self};
    }
}

*value = *QuantLibc::QuoteHandle_value;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableQuoteHandle ##############

package QuantLib::RelinkableQuoteHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::QuoteHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableQuoteHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableQuoteHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableQuoteHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SimpleQuote ##############

package QuantLib::SimpleQuote;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Quote QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SimpleQuote(@_);
    bless $self, $pkg if defined($self);
}

*setValue = *QuantLibc::SimpleQuote_setValue;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SimpleQuote($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::QuoteVector ##############

package QuantLib::QuoteVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_QuoteVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::QuoteVector_size;
*empty = *QuantLibc::QuoteVector_empty;
*clear = *QuantLibc::QuoteVector_clear;
*push = *QuantLibc::QuoteVector_push;
*pop = *QuantLibc::QuoteVector_pop;
*get = *QuantLibc::QuoteVector_get;
*set = *QuantLibc::QuoteVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_QuoteVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::QuoteVectorVector ##############

package QuantLib::QuoteVectorVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_QuoteVectorVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::QuoteVectorVector_size;
*empty = *QuantLibc::QuoteVectorVector_empty;
*clear = *QuantLibc::QuoteVectorVector_clear;
*push = *QuantLibc::QuoteVectorVector_push;
*pop = *QuantLibc::QuoteVectorVector_pop;
*get = *QuantLibc::QuoteVectorVector_get;
*set = *QuantLibc::QuoteVectorVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_QuoteVectorVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::QuoteHandleVector ##############

package QuantLib::QuoteHandleVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_QuoteHandleVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::QuoteHandleVector_size;
*empty = *QuantLibc::QuoteHandleVector_empty;
*clear = *QuantLibc::QuoteHandleVector_clear;
*push = *QuantLibc::QuoteHandleVector_push;
*pop = *QuantLibc::QuoteHandleVector_pop;
*get = *QuantLibc::QuoteHandleVector_get;
*set = *QuantLibc::QuoteHandleVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_QuoteHandleVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::QuoteHandleVectorVector ##############

package QuantLib::QuoteHandleVectorVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_QuoteHandleVectorVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::QuoteHandleVectorVector_size;
*empty = *QuantLibc::QuoteHandleVectorVector_empty;
*clear = *QuantLibc::QuoteHandleVectorVector_clear;
*push = *QuantLibc::QuoteHandleVectorVector_push;
*pop = *QuantLibc::QuoteHandleVectorVector_pop;
*get = *QuantLibc::QuoteHandleVectorVector_get;
*set = *QuantLibc::QuoteHandleVectorVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_QuoteHandleVectorVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableQuoteHandleVector ##############

package QuantLib::RelinkableQuoteHandleVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableQuoteHandleVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::RelinkableQuoteHandleVector_size;
*empty = *QuantLibc::RelinkableQuoteHandleVector_empty;
*clear = *QuantLibc::RelinkableQuoteHandleVector_clear;
*push = *QuantLibc::RelinkableQuoteHandleVector_push;
*pop = *QuantLibc::RelinkableQuoteHandleVector_pop;
*get = *QuantLibc::RelinkableQuoteHandleVector_get;
*set = *QuantLibc::RelinkableQuoteHandleVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableQuoteHandleVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableQuoteHandleVectorVector ##############

package QuantLib::RelinkableQuoteHandleVectorVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableQuoteHandleVectorVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::RelinkableQuoteHandleVectorVector_size;
*empty = *QuantLibc::RelinkableQuoteHandleVectorVector_empty;
*clear = *QuantLibc::RelinkableQuoteHandleVectorVector_clear;
*push = *QuantLibc::RelinkableQuoteHandleVectorVector_push;
*pop = *QuantLibc::RelinkableQuoteHandleVectorVector_pop;
*get = *QuantLibc::RelinkableQuoteHandleVectorVector_get;
*set = *QuantLibc::RelinkableQuoteHandleVectorVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableQuoteHandleVectorVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Calendar ##############

package QuantLib::Calendar;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*isWeekend = *QuantLibc::Calendar_isWeekend;
*endOfMonth = *QuantLibc::Calendar_endOfMonth;
*isBusinessDay = *QuantLibc::Calendar_isBusinessDay;
*isHoliday = *QuantLibc::Calendar_isHoliday;
*isEndOfMonth = *QuantLibc::Calendar_isEndOfMonth;
*addHoliday = *QuantLibc::Calendar_addHoliday;
*removeHoliday = *QuantLibc::Calendar_removeHoliday;
*adjust = *QuantLibc::Calendar_adjust;
*advance = *QuantLibc::Calendar_advance;
*businessDaysBetween = *QuantLibc::Calendar_businessDaysBetween;
*name = *QuantLibc::Calendar_name;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Calendar($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Argentina ##############

package QuantLib::Argentina;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*Merval = *QuantLibc::Argentina_Merval;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Argentina(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Argentina($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Australia ##############

package QuantLib::Australia;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Australia(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Australia($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Brazil ##############

package QuantLib::Brazil;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*Settlement = *QuantLibc::Brazil_Settlement;
*Exchange = *QuantLibc::Brazil_Exchange;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Brazil(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Brazil($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Canada ##############

package QuantLib::Canada;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*Settlement = *QuantLibc::Canada_Settlement;
*TSX = *QuantLibc::Canada_TSX;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Canada(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Canada($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::China ##############

package QuantLib::China;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*SSE = *QuantLibc::China_SSE;
*IB = *QuantLibc::China_IB;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_China(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_China($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CzechRepublic ##############

package QuantLib::CzechRepublic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*PSE = *QuantLibc::CzechRepublic_PSE;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CzechRepublic(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CzechRepublic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Denmark ##############

package QuantLib::Denmark;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Denmark(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Denmark($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Finland ##############

package QuantLib::Finland;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Finland(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Finland($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Germany ##############

package QuantLib::Germany;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*Settlement = *QuantLibc::Germany_Settlement;
*FrankfurtStockExchange = *QuantLibc::Germany_FrankfurtStockExchange;
*Xetra = *QuantLibc::Germany_Xetra;
*Eurex = *QuantLibc::Germany_Eurex;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Germany(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Germany($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HongKong ##############

package QuantLib::HongKong;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*HKEx = *QuantLibc::HongKong_HKEx;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HongKong(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HongKong($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Hungary ##############

package QuantLib::Hungary;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Hungary(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Hungary($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Iceland ##############

package QuantLib::Iceland;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*ICEX = *QuantLibc::Iceland_ICEX;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Iceland(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Iceland($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::India ##############

package QuantLib::India;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*NSE = *QuantLibc::India_NSE;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_India(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_India($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Indonesia ##############

package QuantLib::Indonesia;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*BEJ = *QuantLibc::Indonesia_BEJ;
*JSX = *QuantLibc::Indonesia_JSX;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Indonesia(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Indonesia($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Israel ##############

package QuantLib::Israel;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*Settlement = *QuantLibc::Israel_Settlement;
*TASE = *QuantLibc::Israel_TASE;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Israel(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Israel($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Italy ##############

package QuantLib::Italy;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*Settlement = *QuantLibc::Italy_Settlement;
*Exchange = *QuantLibc::Italy_Exchange;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Italy(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Italy($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Japan ##############

package QuantLib::Japan;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Japan(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Japan($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Mexico ##############

package QuantLib::Mexico;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*BMV = *QuantLibc::Mexico_BMV;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Mexico(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Mexico($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NewZealand ##############

package QuantLib::NewZealand;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NewZealand(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NewZealand($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Norway ##############

package QuantLib::Norway;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Norway(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Norway($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Poland ##############

package QuantLib::Poland;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Poland(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Poland($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Russia ##############

package QuantLib::Russia;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*Settlement = *QuantLibc::Russia_Settlement;
*MOEX = *QuantLibc::Russia_MOEX;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Russia(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Russia($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Romania ##############

package QuantLib::Romania;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Romania(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Romania($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SaudiArabia ##############

package QuantLib::SaudiArabia;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*Tadawul = *QuantLibc::SaudiArabia_Tadawul;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SaudiArabia(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SaudiArabia($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Singapore ##############

package QuantLib::Singapore;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*SGX = *QuantLibc::Singapore_SGX;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Singapore(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Singapore($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Slovakia ##############

package QuantLib::Slovakia;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*BSSE = *QuantLibc::Slovakia_BSSE;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Slovakia(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Slovakia($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SouthAfrica ##############

package QuantLib::SouthAfrica;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SouthAfrica(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SouthAfrica($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SouthKorea ##############

package QuantLib::SouthKorea;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*Settlement = *QuantLibc::SouthKorea_Settlement;
*KRX = *QuantLibc::SouthKorea_KRX;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SouthKorea(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SouthKorea($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Sweden ##############

package QuantLib::Sweden;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Sweden(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Sweden($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Switzerland ##############

package QuantLib::Switzerland;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Switzerland(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Switzerland($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Taiwan ##############

package QuantLib::Taiwan;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*TSEC = *QuantLibc::Taiwan_TSEC;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Taiwan(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Taiwan($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TARGET ##############

package QuantLib::TARGET;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TARGET(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TARGET($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Turkey ##############

package QuantLib::Turkey;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Turkey(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Turkey($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Ukraine ##############

package QuantLib::Ukraine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*USE = *QuantLibc::Ukraine_USE;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Ukraine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Ukraine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::UnitedKingdom ##############

package QuantLib::UnitedKingdom;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*Settlement = *QuantLibc::UnitedKingdom_Settlement;
*Exchange = *QuantLibc::UnitedKingdom_Exchange;
*Metals = *QuantLibc::UnitedKingdom_Metals;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_UnitedKingdom(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_UnitedKingdom($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::UnitedStates ##############

package QuantLib::UnitedStates;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
*Settlement = *QuantLibc::UnitedStates_Settlement;
*NYSE = *QuantLibc::UnitedStates_NYSE;
*GovernmentBond = *QuantLibc::UnitedStates_GovernmentBond;
*NERC = *QuantLibc::UnitedStates_NERC;
*LiborImpact = *QuantLibc::UnitedStates_LiborImpact;
*FederalReserve = *QuantLibc::UnitedStates_FederalReserve;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_UnitedStates(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_UnitedStates($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NullCalendar ##############

package QuantLib::NullCalendar;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NullCalendar(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NullCalendar($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::WeekendsOnly ##############

package QuantLib::WeekendsOnly;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_WeekendsOnly(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_WeekendsOnly($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::JointCalendar ##############

package QuantLib::JointCalendar;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_JointCalendar(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_JointCalendar($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BespokeCalendar ##############

package QuantLib::BespokeCalendar;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Calendar QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BespokeCalendar(@_);
    bless $self, $pkg if defined($self);
}

*addWeekend = *QuantLibc::BespokeCalendar_addWeekend;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BespokeCalendar($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DayCounter ##############

package QuantLib::DayCounter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*dayCount = *QuantLibc::DayCounter_dayCount;
*yearFraction = *QuantLibc::DayCounter_yearFraction;
*name = *QuantLibc::DayCounter_name;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DayCounter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Actual360 ##############

package QuantLib::Actual360;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DayCounter QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Actual360(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Actual360($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Actual365Fixed ##############

package QuantLib::Actual365Fixed;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DayCounter QuantLib );
%OWNER = ();
%ITERATORS = ();
*Standard = *QuantLibc::Actual365Fixed_Standard;
*Canadian = *QuantLibc::Actual365Fixed_Canadian;
*NoLeap = *QuantLibc::Actual365Fixed_NoLeap;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Actual365Fixed(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Actual365Fixed($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Thirty360 ##############

package QuantLib::Thirty360;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DayCounter QuantLib );
%OWNER = ();
%ITERATORS = ();
*USA = *QuantLibc::Thirty360_USA;
*BondBasis = *QuantLibc::Thirty360_BondBasis;
*European = *QuantLibc::Thirty360_European;
*EurobondBasis = *QuantLibc::Thirty360_EurobondBasis;
*Italian = *QuantLibc::Thirty360_Italian;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Thirty360(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Thirty360($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ActualActual ##############

package QuantLib::ActualActual;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DayCounter QuantLib );
%OWNER = ();
%ITERATORS = ();
*ISMA = *QuantLibc::ActualActual_ISMA;
*Bond = *QuantLibc::ActualActual_Bond;
*ISDA = *QuantLibc::ActualActual_ISDA;
*Historical = *QuantLibc::ActualActual_Historical;
*Actual365 = *QuantLibc::ActualActual_Actual365;
*AFB = *QuantLibc::ActualActual_AFB;
*Euro = *QuantLibc::ActualActual_Euro;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ActualActual(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ActualActual($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::OneDayCounter ##############

package QuantLib::OneDayCounter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DayCounter QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_OneDayCounter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_OneDayCounter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SimpleDayCounter ##############

package QuantLib::SimpleDayCounter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DayCounter QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SimpleDayCounter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SimpleDayCounter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Business252 ##############

package QuantLib::Business252;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DayCounter QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Business252(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Business252($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InterestRate ##############

package QuantLib::InterestRate;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InterestRate(@_);
    bless $self, $pkg if defined($self);
}

*rate = *QuantLibc::InterestRate_rate;
*dayCounter = *QuantLibc::InterestRate_dayCounter;
*compounding = *QuantLibc::InterestRate_compounding;
*frequency = *QuantLibc::InterestRate_frequency;
*discountFactor = *QuantLibc::InterestRate_discountFactor;
*compoundFactor = *QuantLibc::InterestRate_compoundFactor;
*impliedRate = *QuantLibc::InterestRate_impliedRate;
*equivalentRate = *QuantLibc::InterestRate_equivalentRate;
*to_string = *QuantLibc::InterestRate_to_string;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InterestRate($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InterestRateVector ##############

package QuantLib::InterestRateVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InterestRateVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::InterestRateVector_size;
*empty = *QuantLibc::InterestRateVector_empty;
*clear = *QuantLibc::InterestRateVector_clear;
*push = *QuantLibc::InterestRateVector_push;
*pop = *QuantLibc::InterestRateVector_pop;
*get = *QuantLibc::InterestRateVector_get;
*set = *QuantLibc::InterestRateVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InterestRateVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Rounding ##############

package QuantLib::Rounding;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Rounding(@_);
    bless $self, $pkg if defined($self);
}

*apply = *QuantLibc::Rounding_apply;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Rounding($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::UpRounding ##############

package QuantLib::UpRounding;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Rounding QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_UpRounding(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_UpRounding($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DownRounding ##############

package QuantLib::DownRounding;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Rounding QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DownRounding(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DownRounding($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ClosestRounding ##############

package QuantLib::ClosestRounding;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Rounding QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ClosestRounding(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ClosestRounding($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CeilingTruncation ##############

package QuantLib::CeilingTruncation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Rounding QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CeilingTruncation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CeilingTruncation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FloorTruncation ##############

package QuantLib::FloorTruncation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Rounding QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FloorTruncation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FloorTruncation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Currency ##############

package QuantLib::Currency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*name = *QuantLibc::Currency_name;
*code = *QuantLibc::Currency_code;
*numericCode = *QuantLibc::Currency_numericCode;
*symbol = *QuantLibc::Currency_symbol;
*fractionSymbol = *QuantLibc::Currency_fractionSymbol;
*fractionsPerUnit = *QuantLibc::Currency_fractionsPerUnit;
*rounding = *QuantLibc::Currency_rounding;
*format = *QuantLibc::Currency_format;
*empty = *QuantLibc::Currency_empty;
*triangulationCurrency = *QuantLibc::Currency_triangulationCurrency;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Currency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Currency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ARSCurrency ##############

package QuantLib::ARSCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ARSCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ARSCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ATSCurrency ##############

package QuantLib::ATSCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ATSCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ATSCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AUDCurrency ##############

package QuantLib::AUDCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AUDCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AUDCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BDTCurrency ##############

package QuantLib::BDTCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BDTCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BDTCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BEFCurrency ##############

package QuantLib::BEFCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BEFCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BEFCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BGLCurrency ##############

package QuantLib::BGLCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BGLCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BGLCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BRLCurrency ##############

package QuantLib::BRLCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BRLCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BRLCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BYRCurrency ##############

package QuantLib::BYRCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BYRCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BYRCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CADCurrency ##############

package QuantLib::CADCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CADCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CADCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CHFCurrency ##############

package QuantLib::CHFCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CHFCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CHFCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CLPCurrency ##############

package QuantLib::CLPCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CLPCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CLPCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CNYCurrency ##############

package QuantLib::CNYCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CNYCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CNYCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::COPCurrency ##############

package QuantLib::COPCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_COPCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_COPCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CYPCurrency ##############

package QuantLib::CYPCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CYPCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CYPCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CZKCurrency ##############

package QuantLib::CZKCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CZKCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CZKCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DEMCurrency ##############

package QuantLib::DEMCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DEMCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DEMCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DKKCurrency ##############

package QuantLib::DKKCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DKKCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DKKCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EEKCurrency ##############

package QuantLib::EEKCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EEKCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EEKCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ESPCurrency ##############

package QuantLib::ESPCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ESPCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ESPCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURCurrency ##############

package QuantLib::EURCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FIMCurrency ##############

package QuantLib::FIMCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FIMCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FIMCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FRFCurrency ##############

package QuantLib::FRFCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FRFCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FRFCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GBPCurrency ##############

package QuantLib::GBPCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GBPCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GBPCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GRDCurrency ##############

package QuantLib::GRDCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GRDCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GRDCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HKDCurrency ##############

package QuantLib::HKDCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HKDCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HKDCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HUFCurrency ##############

package QuantLib::HUFCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HUFCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HUFCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IEPCurrency ##############

package QuantLib::IEPCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IEPCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IEPCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IDRCurrency ##############

package QuantLib::IDRCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IDRCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IDRCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ILSCurrency ##############

package QuantLib::ILSCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ILSCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ILSCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::INRCurrency ##############

package QuantLib::INRCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_INRCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_INRCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IQDCurrency ##############

package QuantLib::IQDCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IQDCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IQDCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IRRCurrency ##############

package QuantLib::IRRCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IRRCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IRRCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ISKCurrency ##############

package QuantLib::ISKCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ISKCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ISKCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ITLCurrency ##############

package QuantLib::ITLCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ITLCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ITLCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::JPYCurrency ##############

package QuantLib::JPYCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_JPYCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_JPYCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::KRWCurrency ##############

package QuantLib::KRWCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_KRWCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_KRWCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::KWDCurrency ##############

package QuantLib::KWDCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_KWDCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_KWDCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LTLCurrency ##############

package QuantLib::LTLCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LTLCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LTLCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LUFCurrency ##############

package QuantLib::LUFCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LUFCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LUFCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LVLCurrency ##############

package QuantLib::LVLCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LVLCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LVLCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MTLCurrency ##############

package QuantLib::MTLCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MTLCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MTLCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MXNCurrency ##############

package QuantLib::MXNCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MXNCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MXNCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MYRCurrency ##############

package QuantLib::MYRCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MYRCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MYRCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NLGCurrency ##############

package QuantLib::NLGCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NLGCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NLGCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NOKCurrency ##############

package QuantLib::NOKCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NOKCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NOKCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NPRCurrency ##############

package QuantLib::NPRCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NPRCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NPRCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NZDCurrency ##############

package QuantLib::NZDCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NZDCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NZDCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PEHCurrency ##############

package QuantLib::PEHCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PEHCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PEHCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PEICurrency ##############

package QuantLib::PEICurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PEICurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PEICurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PENCurrency ##############

package QuantLib::PENCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PENCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PENCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PKRCurrency ##############

package QuantLib::PKRCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PKRCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PKRCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PLNCurrency ##############

package QuantLib::PLNCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PLNCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PLNCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PTECurrency ##############

package QuantLib::PTECurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PTECurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PTECurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ROLCurrency ##############

package QuantLib::ROLCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ROLCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ROLCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RONCurrency ##############

package QuantLib::RONCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RONCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RONCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RUBCurrency ##############

package QuantLib::RUBCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RUBCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RUBCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SARCurrency ##############

package QuantLib::SARCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SARCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SARCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SEKCurrency ##############

package QuantLib::SEKCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SEKCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SEKCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SGDCurrency ##############

package QuantLib::SGDCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SGDCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SGDCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SITCurrency ##############

package QuantLib::SITCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SITCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SITCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SKKCurrency ##############

package QuantLib::SKKCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SKKCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SKKCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::THBCurrency ##############

package QuantLib::THBCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_THBCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_THBCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TRLCurrency ##############

package QuantLib::TRLCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TRLCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TRLCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TRYCurrency ##############

package QuantLib::TRYCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TRYCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TRYCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TTDCurrency ##############

package QuantLib::TTDCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TTDCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TTDCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TWDCurrency ##############

package QuantLib::TWDCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TWDCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TWDCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::USDCurrency ##############

package QuantLib::USDCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_USDCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_USDCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::VEBCurrency ##############

package QuantLib::VEBCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_VEBCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_VEBCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::VNDCurrency ##############

package QuantLib::VNDCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_VNDCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_VNDCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZARCurrency ##############

package QuantLib::ZARCurrency;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Currency QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZARCurrency(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZARCurrency($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LinearInterpolation ##############

package QuantLib::LinearInterpolation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LinearInterpolation(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::LinearInterpolation_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LinearInterpolation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LogLinearInterpolation ##############

package QuantLib::LogLinearInterpolation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LogLinearInterpolation(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::LogLinearInterpolation_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LogLinearInterpolation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BackwardFlatInterpolation ##############

package QuantLib::BackwardFlatInterpolation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BackwardFlatInterpolation(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::BackwardFlatInterpolation_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BackwardFlatInterpolation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ForwardFlatInterpolation ##############

package QuantLib::ForwardFlatInterpolation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ForwardFlatInterpolation(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::ForwardFlatInterpolation_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ForwardFlatInterpolation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CubicNaturalSpline ##############

package QuantLib::CubicNaturalSpline;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CubicNaturalSpline(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::CubicNaturalSpline_call;
*derivative = *QuantLibc::CubicNaturalSpline_derivative;
*secondDerivative = *QuantLibc::CubicNaturalSpline_secondDerivative;
*primitive = *QuantLibc::CubicNaturalSpline_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CubicNaturalSpline($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LogCubicNaturalSpline ##############

package QuantLib::LogCubicNaturalSpline;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LogCubicNaturalSpline(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::LogCubicNaturalSpline_call;
*derivative = *QuantLibc::LogCubicNaturalSpline_derivative;
*secondDerivative = *QuantLibc::LogCubicNaturalSpline_secondDerivative;
*primitive = *QuantLibc::LogCubicNaturalSpline_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LogCubicNaturalSpline($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MonotonicCubicNaturalSpline ##############

package QuantLib::MonotonicCubicNaturalSpline;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MonotonicCubicNaturalSpline(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::MonotonicCubicNaturalSpline_call;
*derivative = *QuantLibc::MonotonicCubicNaturalSpline_derivative;
*secondDerivative = *QuantLibc::MonotonicCubicNaturalSpline_secondDerivative;
*primitive = *QuantLibc::MonotonicCubicNaturalSpline_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MonotonicCubicNaturalSpline($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MonotonicLogCubicNaturalSpline ##############

package QuantLib::MonotonicLogCubicNaturalSpline;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MonotonicLogCubicNaturalSpline(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::MonotonicLogCubicNaturalSpline_call;
*derivative = *QuantLibc::MonotonicLogCubicNaturalSpline_derivative;
*secondDerivative = *QuantLibc::MonotonicLogCubicNaturalSpline_secondDerivative;
*primitive = *QuantLibc::MonotonicLogCubicNaturalSpline_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MonotonicLogCubicNaturalSpline($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::KrugerCubic ##############

package QuantLib::KrugerCubic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_KrugerCubic(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::KrugerCubic_call;
*derivative = *QuantLibc::KrugerCubic_derivative;
*secondDerivative = *QuantLibc::KrugerCubic_secondDerivative;
*primitive = *QuantLibc::KrugerCubic_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_KrugerCubic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::KrugerLogCubic ##############

package QuantLib::KrugerLogCubic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_KrugerLogCubic(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::KrugerLogCubic_call;
*derivative = *QuantLibc::KrugerLogCubic_derivative;
*secondDerivative = *QuantLibc::KrugerLogCubic_secondDerivative;
*primitive = *QuantLibc::KrugerLogCubic_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_KrugerLogCubic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FritschButlandCubic ##############

package QuantLib::FritschButlandCubic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FritschButlandCubic(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::FritschButlandCubic_call;
*derivative = *QuantLibc::FritschButlandCubic_derivative;
*secondDerivative = *QuantLibc::FritschButlandCubic_secondDerivative;
*primitive = *QuantLibc::FritschButlandCubic_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FritschButlandCubic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FritschButlandLogCubic ##############

package QuantLib::FritschButlandLogCubic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FritschButlandLogCubic(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::FritschButlandLogCubic_call;
*derivative = *QuantLibc::FritschButlandLogCubic_derivative;
*secondDerivative = *QuantLibc::FritschButlandLogCubic_secondDerivative;
*primitive = *QuantLibc::FritschButlandLogCubic_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FritschButlandLogCubic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Parabolic ##############

package QuantLib::Parabolic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Parabolic(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::Parabolic_call;
*derivative = *QuantLibc::Parabolic_derivative;
*secondDerivative = *QuantLibc::Parabolic_secondDerivative;
*primitive = *QuantLibc::Parabolic_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Parabolic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LogParabolic ##############

package QuantLib::LogParabolic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LogParabolic(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::LogParabolic_call;
*derivative = *QuantLibc::LogParabolic_derivative;
*secondDerivative = *QuantLibc::LogParabolic_secondDerivative;
*primitive = *QuantLibc::LogParabolic_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LogParabolic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MonotonicParabolic ##############

package QuantLib::MonotonicParabolic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MonotonicParabolic(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::MonotonicParabolic_call;
*derivative = *QuantLibc::MonotonicParabolic_derivative;
*secondDerivative = *QuantLibc::MonotonicParabolic_secondDerivative;
*primitive = *QuantLibc::MonotonicParabolic_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MonotonicParabolic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MonotonicLogParabolic ##############

package QuantLib::MonotonicLogParabolic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MonotonicLogParabolic(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::MonotonicLogParabolic_call;
*derivative = *QuantLibc::MonotonicLogParabolic_derivative;
*secondDerivative = *QuantLibc::MonotonicLogParabolic_secondDerivative;
*primitive = *QuantLibc::MonotonicLogParabolic_primitive;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MonotonicLogParabolic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BilinearInterpolation ##############

package QuantLib::BilinearInterpolation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BilinearInterpolation(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::BilinearInterpolation_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BilinearInterpolation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BicubicSpline ##############

package QuantLib::BicubicSpline;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BicubicSpline(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::BicubicSpline_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BicubicSpline($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BackwardFlat ##############

package QuantLib::BackwardFlat;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BackwardFlat(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BackwardFlat($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ForwardFlat ##############

package QuantLib::ForwardFlat;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ForwardFlat(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ForwardFlat($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Linear ##############

package QuantLib::Linear;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Linear(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Linear($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LogLinear ##############

package QuantLib::LogLinear;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LogLinear(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LogLinear($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Cubic ##############

package QuantLib::Cubic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Cubic(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Cubic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MonotonicCubic ##############

package QuantLib::MonotonicCubic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MonotonicCubic(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MonotonicCubic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DefaultLogCubic ##############

package QuantLib::DefaultLogCubic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DefaultLogCubic(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DefaultLogCubic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MonotonicLogCubic ##############

package QuantLib::MonotonicLogCubic;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MonotonicLogCubic(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MonotonicLogCubic($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YieldTermStructure ##############

package QuantLib::YieldTermStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::YieldTermStructure___deref__;
*isNull = *QuantLibc::YieldTermStructure_isNull;
*asObservable = *QuantLibc::YieldTermStructure_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YieldTermStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YieldTermStructure($self);
        delete $OWNER{$self};
    }
}

*dayCounter = *QuantLibc::YieldTermStructure_dayCounter;
*calendar = *QuantLibc::YieldTermStructure_calendar;
*referenceDate = *QuantLibc::YieldTermStructure_referenceDate;
*maxDate = *QuantLibc::YieldTermStructure_maxDate;
*maxTime = *QuantLibc::YieldTermStructure_maxTime;
*discount = *QuantLibc::YieldTermStructure_discount;
*zeroRate = *QuantLibc::YieldTermStructure_zeroRate;
*forwardRate = *QuantLibc::YieldTermStructure_forwardRate;
*enableExtrapolation = *QuantLibc::YieldTermStructure_enableExtrapolation;
*disableExtrapolation = *QuantLibc::YieldTermStructure_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::YieldTermStructure_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YieldTermStructureHandle ##############

package QuantLib::YieldTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YieldTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::YieldTermStructureHandle___deref__;
*empty = *QuantLibc::YieldTermStructureHandle_empty;
*asObservable = *QuantLibc::YieldTermStructureHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YieldTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

*dayCounter = *QuantLibc::YieldTermStructureHandle_dayCounter;
*calendar = *QuantLibc::YieldTermStructureHandle_calendar;
*referenceDate = *QuantLibc::YieldTermStructureHandle_referenceDate;
*maxDate = *QuantLibc::YieldTermStructureHandle_maxDate;
*maxTime = *QuantLibc::YieldTermStructureHandle_maxTime;
*discount = *QuantLibc::YieldTermStructureHandle_discount;
*zeroRate = *QuantLibc::YieldTermStructureHandle_zeroRate;
*forwardRate = *QuantLibc::YieldTermStructureHandle_forwardRate;
*enableExtrapolation = *QuantLibc::YieldTermStructureHandle_enableExtrapolation;
*disableExtrapolation = *QuantLibc::YieldTermStructureHandle_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::YieldTermStructureHandle_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableYieldTermStructureHandle ##############

package QuantLib::RelinkableYieldTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructureHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableYieldTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableYieldTermStructureHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableYieldTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ImpliedTermStructure ##############

package QuantLib::ImpliedTermStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ImpliedTermStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ImpliedTermStructure($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZeroSpreadedTermStructure ##############

package QuantLib::ZeroSpreadedTermStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZeroSpreadedTermStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZeroSpreadedTermStructure($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ForwardSpreadedTermStructure ##############

package QuantLib::ForwardSpreadedTermStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ForwardSpreadedTermStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ForwardSpreadedTermStructure($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SpreadedLinearZeroInterpolatedTermStructure ##############

package QuantLib::SpreadedLinearZeroInterpolatedTermStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SpreadedLinearZeroInterpolatedTermStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SpreadedLinearZeroInterpolatedTermStructure($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FlatForward ##############

package QuantLib::FlatForward;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FlatForward(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FlatForward($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RealTimeSeries ##############

package QuantLib::RealTimeSeries;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RealTimeSeries(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::RealTimeSeries_dates;
*values = *QuantLibc::RealTimeSeries_values;
*size = *QuantLibc::RealTimeSeries_size;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RealTimeSeries($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IntervalPriceTimeSeries ##############

package QuantLib::IntervalPriceTimeSeries;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IntervalPriceTimeSeries(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::IntervalPriceTimeSeries_dates;
*values = *QuantLibc::IntervalPriceTimeSeries_values;
*size = *QuantLibc::IntervalPriceTimeSeries_size;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IntervalPriceTimeSeries($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IntervalPriceVector ##############

package QuantLib::IntervalPriceVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IntervalPriceVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::IntervalPriceVector_size;
*empty = *QuantLibc::IntervalPriceVector_empty;
*clear = *QuantLibc::IntervalPriceVector_clear;
*push = *QuantLibc::IntervalPriceVector_push;
*pop = *QuantLibc::IntervalPriceVector_pop;
*get = *QuantLibc::IntervalPriceVector_get;
*set = *QuantLibc::IntervalPriceVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IntervalPriceVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IntervalPrice ##############

package QuantLib::IntervalPrice;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Open = *QuantLibc::IntervalPrice_Open;
*Close = *QuantLibc::IntervalPrice_Close;
*High = *QuantLibc::IntervalPrice_High;
*Low = *QuantLibc::IntervalPrice_Low;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IntervalPrice(@_);
    bless $self, $pkg if defined($self);
}

*setValue = *QuantLibc::IntervalPrice_setValue;
*setValues = *QuantLibc::IntervalPrice_setValues;
*value = *QuantLibc::IntervalPrice_value;
*open = *QuantLibc::IntervalPrice_open;
*close = *QuantLibc::IntervalPrice_close;
*high = *QuantLibc::IntervalPrice_high;
*low = *QuantLibc::IntervalPrice_low;
*makeSeries = *QuantLibc::IntervalPrice_makeSeries;
*extractValues = *QuantLibc::IntervalPrice_extractValues;
*extractComponent = *QuantLibc::IntervalPrice_extractComponent;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IntervalPrice($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IndexManager ##############

package QuantLib::IndexManager;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*instance = *QuantLibc::IndexManager_instance;
*setHistory = *QuantLibc::IndexManager_setHistory;
*getHistory = *QuantLibc::IndexManager_getHistory;
*hasHistory = *QuantLibc::IndexManager_hasHistory;
*histories = *QuantLibc::IndexManager_histories;
*clearHistory = *QuantLibc::IndexManager_clearHistory;
*clearHistories = *QuantLibc::IndexManager_clearHistories;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IndexManager($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Index ##############

package QuantLib::Index;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::Index___deref__;
*isNull = *QuantLibc::Index_isNull;
*addFixings = *QuantLibc::Index_addFixings;
*asObservable = *QuantLibc::Index_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Index(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Index($self);
        delete $OWNER{$self};
    }
}

*name = *QuantLibc::Index_name;
*fixingCalendar = *QuantLibc::Index_fixingCalendar;
*isValidFixingDate = *QuantLibc::Index_isValidFixingDate;
*fixing = *QuantLibc::Index_fixing;
*addFixing = *QuantLibc::Index_addFixing;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InterestRateIndex ##############

package QuantLib::InterestRateIndex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Index QuantLib );
%OWNER = ();
%ITERATORS = ();
*familyName = *QuantLibc::InterestRateIndex_familyName;
*tenor = *QuantLibc::InterestRateIndex_tenor;
*fixingDays = *QuantLibc::InterestRateIndex_fixingDays;
*fixingDate = *QuantLibc::InterestRateIndex_fixingDate;
*currency = *QuantLibc::InterestRateIndex_currency;
*dayCounter = *QuantLibc::InterestRateIndex_dayCounter;
*maturityDate = *QuantLibc::InterestRateIndex_maturityDate;
*valueDate = *QuantLibc::InterestRateIndex_valueDate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InterestRateIndex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IborIndex ##############

package QuantLib::IborIndex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::InterestRateIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IborIndex(@_);
    bless $self, $pkg if defined($self);
}

*businessDayConvention = *QuantLibc::IborIndex_businessDayConvention;
*endOfMonth = *QuantLibc::IborIndex_endOfMonth;
*forwardingTermStructure = *QuantLibc::IborIndex_forwardingTermStructure;
*clone = *QuantLibc::IborIndex_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IborIndex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::OvernightIndex ##############

package QuantLib::OvernightIndex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_OvernightIndex(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_OvernightIndex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Libor ##############

package QuantLib::Libor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Libor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Libor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SwapIndex ##############

package QuantLib::SwapIndex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::InterestRateIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SwapIndex(@_);
    bless $self, $pkg if defined($self);
}

*fixedLegTenor = *QuantLibc::SwapIndex_fixedLegTenor;
*fixedLegConvention = *QuantLibc::SwapIndex_fixedLegConvention;
*iborIndex = *QuantLibc::SwapIndex_iborIndex;
*forwardingTermStructure = *QuantLibc::SwapIndex_forwardingTermStructure;
*discountingTermStructure = *QuantLibc::SwapIndex_discountingTermStructure;
*clone = *QuantLibc::SwapIndex_clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SwapIndex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AUDLibor ##############

package QuantLib::AUDLibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AUDLibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AUDLibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CADLibor ##############

package QuantLib::CADLibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CADLibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CADLibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Cdor ##############

package QuantLib::Cdor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Cdor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Cdor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CHFLibor ##############

package QuantLib::CHFLibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CHFLibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CHFLibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DKKLibor ##############

package QuantLib::DKKLibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DKKLibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DKKLibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bbsw ##############

package QuantLib::Bbsw;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bbsw(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bbsw($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bbsw1M ##############

package QuantLib::Bbsw1M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bbsw QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bbsw1M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bbsw1M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bbsw2M ##############

package QuantLib::Bbsw2M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bbsw QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bbsw2M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bbsw2M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bbsw3M ##############

package QuantLib::Bbsw3M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bbsw QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bbsw3M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bbsw3M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bbsw4M ##############

package QuantLib::Bbsw4M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bbsw QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bbsw4M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bbsw4M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bbsw5M ##############

package QuantLib::Bbsw5M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bbsw QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bbsw5M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bbsw5M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bbsw6M ##############

package QuantLib::Bbsw6M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bbsw QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bbsw6M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bbsw6M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bkbm ##############

package QuantLib::Bkbm;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bkbm(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bkbm($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bkbm1M ##############

package QuantLib::Bkbm1M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bkbm QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bkbm1M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bkbm1M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bkbm2M ##############

package QuantLib::Bkbm2M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bkbm QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bkbm2M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bkbm2M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bkbm3M ##############

package QuantLib::Bkbm3M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bkbm QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bkbm3M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bkbm3M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bkbm4M ##############

package QuantLib::Bkbm4M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bkbm QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bkbm4M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bkbm4M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bkbm5M ##############

package QuantLib::Bkbm5M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bkbm QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bkbm5M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bkbm5M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bkbm6M ##############

package QuantLib::Bkbm6M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bkbm QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bkbm6M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bkbm6M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor ##############

package QuantLib::Euribor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EuriborSW ##############

package QuantLib::EuriborSW;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EuriborSW(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EuriborSW($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor2W ##############

package QuantLib::Euribor2W;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor2W(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor2W($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor3W ##############

package QuantLib::Euribor3W;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor3W(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor3W($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor1M ##############

package QuantLib::Euribor1M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor1M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor1M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor2M ##############

package QuantLib::Euribor2M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor2M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor2M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor3M ##############

package QuantLib::Euribor3M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor3M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor3M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor4M ##############

package QuantLib::Euribor4M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor4M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor4M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor5M ##############

package QuantLib::Euribor5M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor5M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor5M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor6M ##############

package QuantLib::Euribor6M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor6M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor6M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor7M ##############

package QuantLib::Euribor7M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor7M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor7M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor8M ##############

package QuantLib::Euribor8M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor8M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor8M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor9M ##############

package QuantLib::Euribor9M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor9M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor9M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor10M ##############

package QuantLib::Euribor10M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor10M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor10M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor11M ##############

package QuantLib::Euribor11M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor11M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor11M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor1Y ##############

package QuantLib::Euribor1Y;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor1Y(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor1Y($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365 ##############

package QuantLib::Euribor365;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_SW ##############

package QuantLib::Euribor365_SW;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_SW(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_SW($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_2W ##############

package QuantLib::Euribor365_2W;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_2W(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_2W($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_3W ##############

package QuantLib::Euribor365_3W;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_3W(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_3W($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_1M ##############

package QuantLib::Euribor365_1M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_1M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_1M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_2M ##############

package QuantLib::Euribor365_2M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_2M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_2M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_3M ##############

package QuantLib::Euribor365_3M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_3M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_3M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_4M ##############

package QuantLib::Euribor365_4M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_4M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_4M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_5M ##############

package QuantLib::Euribor365_5M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_5M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_5M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_6M ##############

package QuantLib::Euribor365_6M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_6M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_6M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_7M ##############

package QuantLib::Euribor365_7M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_7M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_7M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_8M ##############

package QuantLib::Euribor365_8M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_8M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_8M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_9M ##############

package QuantLib::Euribor365_9M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_9M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_9M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_10M ##############

package QuantLib::Euribor365_10M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_10M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_10M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_11M ##############

package QuantLib::Euribor365_11M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_11M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_11M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Euribor365_1Y ##############

package QuantLib::Euribor365_1Y;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Euribor365 QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Euribor365_1Y(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Euribor365_1Y($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor ##############

package QuantLib::EURLibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLiborSW ##############

package QuantLib::EURLiborSW;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLiborSW(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLiborSW($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor2W ##############

package QuantLib::EURLibor2W;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor2W(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor2W($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor1M ##############

package QuantLib::EURLibor1M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor1M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor1M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor2M ##############

package QuantLib::EURLibor2M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor2M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor2M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor3M ##############

package QuantLib::EURLibor3M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor3M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor3M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor4M ##############

package QuantLib::EURLibor4M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor4M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor4M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor5M ##############

package QuantLib::EURLibor5M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor5M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor5M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor6M ##############

package QuantLib::EURLibor6M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor6M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor6M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor7M ##############

package QuantLib::EURLibor7M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor7M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor7M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor8M ##############

package QuantLib::EURLibor8M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor8M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor8M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor9M ##############

package QuantLib::EURLibor9M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor9M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor9M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor10M ##############

package QuantLib::EURLibor10M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor10M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor10M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor11M ##############

package QuantLib::EURLibor11M;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor11M(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor11M($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EURLibor1Y ##############

package QuantLib::EURLibor1Y;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::EURLibor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EURLibor1Y(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EURLibor1Y($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GBPLibor ##############

package QuantLib::GBPLibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GBPLibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GBPLibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Jibar ##############

package QuantLib::Jibar;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Jibar(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Jibar($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::JPYLibor ##############

package QuantLib::JPYLibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_JPYLibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_JPYLibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NZDLibor ##############

package QuantLib::NZDLibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NZDLibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NZDLibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SEKLibor ##############

package QuantLib::SEKLibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SEKLibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SEKLibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Tibor ##############

package QuantLib::Tibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Tibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Tibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TRLibor ##############

package QuantLib::TRLibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TRLibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TRLibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::USDLibor ##############

package QuantLib::USDLibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_USDLibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_USDLibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Zibor ##############

package QuantLib::Zibor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Zibor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Zibor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Aonia ##############

package QuantLib::Aonia;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OvernightIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Aonia(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Aonia($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Eonia ##############

package QuantLib::Eonia;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OvernightIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Eonia(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Eonia($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Sonia ##############

package QuantLib::Sonia;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OvernightIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Sonia(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Sonia($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FedFunds ##############

package QuantLib::FedFunds;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OvernightIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FedFunds(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FedFunds($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Nzocr ##############

package QuantLib::Nzocr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OvernightIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Nzocr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Nzocr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EuriborSwapIsdaFixA ##############

package QuantLib::EuriborSwapIsdaFixA;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EuriborSwapIsdaFixA(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EuriborSwapIsdaFixA($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EuriborSwapIsdaFixB ##############

package QuantLib::EuriborSwapIsdaFixB;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EuriborSwapIsdaFixB(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EuriborSwapIsdaFixB($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EuriborSwapIfrFix ##############

package QuantLib::EuriborSwapIfrFix;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EuriborSwapIfrFix(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EuriborSwapIfrFix($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EurLiborSwapIsdaFixA ##############

package QuantLib::EurLiborSwapIsdaFixA;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EurLiborSwapIsdaFixA(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EurLiborSwapIsdaFixA($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EurLiborSwapIsdaFixB ##############

package QuantLib::EurLiborSwapIsdaFixB;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EurLiborSwapIsdaFixB(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EurLiborSwapIsdaFixB($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EurLiborSwapIfrFix ##############

package QuantLib::EurLiborSwapIfrFix;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EurLiborSwapIfrFix(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EurLiborSwapIfrFix($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ChfLiborSwapIsdaFix ##############

package QuantLib::ChfLiborSwapIsdaFix;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ChfLiborSwapIsdaFix(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ChfLiborSwapIsdaFix($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GbpLiborSwapIsdaFix ##############

package QuantLib::GbpLiborSwapIsdaFix;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GbpLiborSwapIsdaFix(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GbpLiborSwapIsdaFix($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::JpyLiborSwapIsdaFixAm ##############

package QuantLib::JpyLiborSwapIsdaFixAm;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_JpyLiborSwapIsdaFixAm(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_JpyLiborSwapIsdaFixAm($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::JpyLiborSwapIsdaFixPm ##############

package QuantLib::JpyLiborSwapIsdaFixPm;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_JpyLiborSwapIsdaFixPm(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_JpyLiborSwapIsdaFixPm($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::UsdLiborSwapIsdaFixAm ##############

package QuantLib::UsdLiborSwapIsdaFixAm;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_UsdLiborSwapIsdaFixAm(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_UsdLiborSwapIsdaFixAm($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::UsdLiborSwapIsdaFixPm ##############

package QuantLib::UsdLiborSwapIsdaFixPm;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwapIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_UsdLiborSwapIsdaFixPm(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_UsdLiborSwapIsdaFixPm($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Brent ##############

package QuantLib::Brent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*setMaxEvaluations = *QuantLibc::Brent_setMaxEvaluations;
*setLowerBound = *QuantLibc::Brent_setLowerBound;
*setUpperBound = *QuantLibc::Brent_setUpperBound;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Brent(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Brent($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bisection ##############

package QuantLib::Bisection;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*setMaxEvaluations = *QuantLibc::Bisection_setMaxEvaluations;
*setLowerBound = *QuantLibc::Bisection_setLowerBound;
*setUpperBound = *QuantLibc::Bisection_setUpperBound;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bisection(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bisection($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FalsePosition ##############

package QuantLib::FalsePosition;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*setMaxEvaluations = *QuantLibc::FalsePosition_setMaxEvaluations;
*setLowerBound = *QuantLibc::FalsePosition_setLowerBound;
*setUpperBound = *QuantLibc::FalsePosition_setUpperBound;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FalsePosition(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FalsePosition($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Ridder ##############

package QuantLib::Ridder;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*setMaxEvaluations = *QuantLibc::Ridder_setMaxEvaluations;
*setLowerBound = *QuantLibc::Ridder_setLowerBound;
*setUpperBound = *QuantLibc::Ridder_setUpperBound;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Ridder(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Ridder($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Secant ##############

package QuantLib::Secant;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*setMaxEvaluations = *QuantLibc::Secant_setMaxEvaluations;
*setLowerBound = *QuantLibc::Secant_setLowerBound;
*setUpperBound = *QuantLibc::Secant_setUpperBound;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Secant(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Secant($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Constraint ##############

package QuantLib::Constraint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Constraint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BoundaryConstraint ##############

package QuantLib::BoundaryConstraint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Constraint QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BoundaryConstraint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BoundaryConstraint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NoConstraint ##############

package QuantLib::NoConstraint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Constraint QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NoConstraint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NoConstraint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PositiveConstraint ##############

package QuantLib::PositiveConstraint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Constraint QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PositiveConstraint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PositiveConstraint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CompositeConstraint ##############

package QuantLib::CompositeConstraint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Constraint QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CompositeConstraint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CompositeConstraint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NonhomogeneousBoundaryConstraint ##############

package QuantLib::NonhomogeneousBoundaryConstraint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Constraint QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NonhomogeneousBoundaryConstraint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NonhomogeneousBoundaryConstraint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EndCriteria ##############

package QuantLib::EndCriteria;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*None = *QuantLibc::EndCriteria_None;
*MaxIterations = *QuantLibc::EndCriteria_MaxIterations;
*StationaryPoint = *QuantLibc::EndCriteria_StationaryPoint;
*StationaryFunctionValue = *QuantLibc::EndCriteria_StationaryFunctionValue;
*StationaryFunctionAccuracy = *QuantLibc::EndCriteria_StationaryFunctionAccuracy;
*ZeroGradientNorm = *QuantLibc::EndCriteria_ZeroGradientNorm;
*Unknown = *QuantLibc::EndCriteria_Unknown;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EndCriteria(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::EndCriteria_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EndCriteria($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::OptimizationMethod ##############

package QuantLib::OptimizationMethod;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_OptimizationMethod($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ConjugateGradient ##############

package QuantLib::ConjugateGradient;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptimizationMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ConjugateGradient(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ConjugateGradient($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Simplex ##############

package QuantLib::Simplex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptimizationMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Simplex(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Simplex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SteepestDescent ##############

package QuantLib::SteepestDescent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptimizationMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SteepestDescent(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SteepestDescent($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BFGS ##############

package QuantLib::BFGS;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptimizationMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BFGS(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BFGS($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LevenbergMarquardt ##############

package QuantLib::LevenbergMarquardt;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptimizationMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LevenbergMarquardt(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LevenbergMarquardt($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DifferentialEvolution ##############

package QuantLib::DifferentialEvolution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptimizationMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DifferentialEvolution(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DifferentialEvolution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SamplerGaussian ##############

package QuantLib::SamplerGaussian;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SamplerGaussian(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SamplerGaussian($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SamplerLogNormal ##############

package QuantLib::SamplerLogNormal;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SamplerLogNormal(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SamplerLogNormal($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SamplerMirrorGaussian ##############

package QuantLib::SamplerMirrorGaussian;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SamplerMirrorGaussian(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SamplerMirrorGaussian($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ProbabilityBoltzmannDownhill ##############

package QuantLib::ProbabilityBoltzmannDownhill;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ProbabilityBoltzmannDownhill(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ProbabilityBoltzmannDownhill($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TemperatureExponential ##############

package QuantLib::TemperatureExponential;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TemperatureExponential(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TemperatureExponential($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ReannealingTrivial ##############

package QuantLib::ReannealingTrivial;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ReannealingTrivial(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ReannealingTrivial($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussianSimulatedAnnealing ##############

package QuantLib::GaussianSimulatedAnnealing;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptimizationMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
*NoResetScheme = *QuantLibc::GaussianSimulatedAnnealing_NoResetScheme;
*ResetToBestPoint = *QuantLibc::GaussianSimulatedAnnealing_ResetToBestPoint;
*ResetToOrigin = *QuantLibc::GaussianSimulatedAnnealing_ResetToOrigin;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussianSimulatedAnnealing(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussianSimulatedAnnealing($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MirrorGaussianSimulatedAnnealing ##############

package QuantLib::MirrorGaussianSimulatedAnnealing;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptimizationMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
*NoResetScheme = *QuantLibc::MirrorGaussianSimulatedAnnealing_NoResetScheme;
*ResetToBestPoint = *QuantLibc::MirrorGaussianSimulatedAnnealing_ResetToBestPoint;
*ResetToOrigin = *QuantLibc::MirrorGaussianSimulatedAnnealing_ResetToOrigin;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MirrorGaussianSimulatedAnnealing(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MirrorGaussianSimulatedAnnealing($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LogNormalSimulatedAnnealing ##############

package QuantLib::LogNormalSimulatedAnnealing;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptimizationMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
*NoResetScheme = *QuantLibc::LogNormalSimulatedAnnealing_NoResetScheme;
*ResetToBestPoint = *QuantLibc::LogNormalSimulatedAnnealing_ResetToBestPoint;
*ResetToOrigin = *QuantLibc::LogNormalSimulatedAnnealing_ResetToOrigin;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LogNormalSimulatedAnnealing(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LogNormalSimulatedAnnealing($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Optimizer ##############

package QuantLib::Optimizer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Optimizer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Optimizer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackVolTermStructure ##############

package QuantLib::BlackVolTermStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::BlackVolTermStructure___deref__;
*isNull = *QuantLibc::BlackVolTermStructure_isNull;
*asObservable = *QuantLibc::BlackVolTermStructure_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackVolTermStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackVolTermStructure($self);
        delete $OWNER{$self};
    }
}

*referenceDate = *QuantLibc::BlackVolTermStructure_referenceDate;
*dayCounter = *QuantLibc::BlackVolTermStructure_dayCounter;
*calendar = *QuantLibc::BlackVolTermStructure_calendar;
*maxDate = *QuantLibc::BlackVolTermStructure_maxDate;
*maxTime = *QuantLibc::BlackVolTermStructure_maxTime;
*minStrike = *QuantLibc::BlackVolTermStructure_minStrike;
*maxStrike = *QuantLibc::BlackVolTermStructure_maxStrike;
*blackVol = *QuantLibc::BlackVolTermStructure_blackVol;
*blackVariance = *QuantLibc::BlackVolTermStructure_blackVariance;
*blackForwardVol = *QuantLibc::BlackVolTermStructure_blackForwardVol;
*blackForwardVariance = *QuantLibc::BlackVolTermStructure_blackForwardVariance;
*enableExtrapolation = *QuantLibc::BlackVolTermStructure_enableExtrapolation;
*disableExtrapolation = *QuantLibc::BlackVolTermStructure_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::BlackVolTermStructure_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackVolTermStructureHandle ##############

package QuantLib::BlackVolTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackVolTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::BlackVolTermStructureHandle___deref__;
*empty = *QuantLibc::BlackVolTermStructureHandle_empty;
*asObservable = *QuantLibc::BlackVolTermStructureHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackVolTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

*referenceDate = *QuantLibc::BlackVolTermStructureHandle_referenceDate;
*dayCounter = *QuantLibc::BlackVolTermStructureHandle_dayCounter;
*calendar = *QuantLibc::BlackVolTermStructureHandle_calendar;
*maxDate = *QuantLibc::BlackVolTermStructureHandle_maxDate;
*maxTime = *QuantLibc::BlackVolTermStructureHandle_maxTime;
*minStrike = *QuantLibc::BlackVolTermStructureHandle_minStrike;
*maxStrike = *QuantLibc::BlackVolTermStructureHandle_maxStrike;
*blackVol = *QuantLibc::BlackVolTermStructureHandle_blackVol;
*blackVariance = *QuantLibc::BlackVolTermStructureHandle_blackVariance;
*blackForwardVol = *QuantLibc::BlackVolTermStructureHandle_blackForwardVol;
*blackForwardVariance = *QuantLibc::BlackVolTermStructureHandle_blackForwardVariance;
*enableExtrapolation = *QuantLibc::BlackVolTermStructureHandle_enableExtrapolation;
*disableExtrapolation = *QuantLibc::BlackVolTermStructureHandle_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::BlackVolTermStructureHandle_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableBlackVolTermStructureHandle ##############

package QuantLib::RelinkableBlackVolTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::BlackVolTermStructureHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableBlackVolTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableBlackVolTermStructureHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableBlackVolTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LocalVolTermStructure ##############

package QuantLib::LocalVolTermStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::LocalVolTermStructure___deref__;
*isNull = *QuantLibc::LocalVolTermStructure_isNull;
*asObservable = *QuantLibc::LocalVolTermStructure_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LocalVolTermStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LocalVolTermStructure($self);
        delete $OWNER{$self};
    }
}

*referenceDate = *QuantLibc::LocalVolTermStructure_referenceDate;
*dayCounter = *QuantLibc::LocalVolTermStructure_dayCounter;
*calendar = *QuantLibc::LocalVolTermStructure_calendar;
*maxDate = *QuantLibc::LocalVolTermStructure_maxDate;
*maxTime = *QuantLibc::LocalVolTermStructure_maxTime;
*minStrike = *QuantLibc::LocalVolTermStructure_minStrike;
*maxStrike = *QuantLibc::LocalVolTermStructure_maxStrike;
*localVol = *QuantLibc::LocalVolTermStructure_localVol;
*enableExtrapolation = *QuantLibc::LocalVolTermStructure_enableExtrapolation;
*disableExtrapolation = *QuantLibc::LocalVolTermStructure_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::LocalVolTermStructure_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LocalVolTermStructureHandle ##############

package QuantLib::LocalVolTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LocalVolTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::LocalVolTermStructureHandle___deref__;
*empty = *QuantLibc::LocalVolTermStructureHandle_empty;
*asObservable = *QuantLibc::LocalVolTermStructureHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LocalVolTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

*referenceDate = *QuantLibc::LocalVolTermStructureHandle_referenceDate;
*dayCounter = *QuantLibc::LocalVolTermStructureHandle_dayCounter;
*calendar = *QuantLibc::LocalVolTermStructureHandle_calendar;
*maxDate = *QuantLibc::LocalVolTermStructureHandle_maxDate;
*maxTime = *QuantLibc::LocalVolTermStructureHandle_maxTime;
*minStrike = *QuantLibc::LocalVolTermStructureHandle_minStrike;
*maxStrike = *QuantLibc::LocalVolTermStructureHandle_maxStrike;
*localVol = *QuantLibc::LocalVolTermStructureHandle_localVol;
*enableExtrapolation = *QuantLibc::LocalVolTermStructureHandle_enableExtrapolation;
*disableExtrapolation = *QuantLibc::LocalVolTermStructureHandle_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::LocalVolTermStructureHandle_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableLocalVolTermStructureHandle ##############

package QuantLib::RelinkableLocalVolTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::LocalVolTermStructureHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableLocalVolTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableLocalVolTermStructureHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableLocalVolTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::OptionletVolatilityStructure ##############

package QuantLib::OptionletVolatilityStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::OptionletVolatilityStructure___deref__;
*isNull = *QuantLibc::OptionletVolatilityStructure_isNull;
*asObservable = *QuantLibc::OptionletVolatilityStructure_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_OptionletVolatilityStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_OptionletVolatilityStructure($self);
        delete $OWNER{$self};
    }
}

*referenceDate = *QuantLibc::OptionletVolatilityStructure_referenceDate;
*dayCounter = *QuantLibc::OptionletVolatilityStructure_dayCounter;
*calendar = *QuantLibc::OptionletVolatilityStructure_calendar;
*maxDate = *QuantLibc::OptionletVolatilityStructure_maxDate;
*maxTime = *QuantLibc::OptionletVolatilityStructure_maxTime;
*minStrike = *QuantLibc::OptionletVolatilityStructure_minStrike;
*maxStrike = *QuantLibc::OptionletVolatilityStructure_maxStrike;
*volatility = *QuantLibc::OptionletVolatilityStructure_volatility;
*blackVariance = *QuantLibc::OptionletVolatilityStructure_blackVariance;
*enableExtrapolation = *QuantLibc::OptionletVolatilityStructure_enableExtrapolation;
*disableExtrapolation = *QuantLibc::OptionletVolatilityStructure_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::OptionletVolatilityStructure_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::OptionletVolatilityStructureHandle ##############

package QuantLib::OptionletVolatilityStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_OptionletVolatilityStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::OptionletVolatilityStructureHandle___deref__;
*empty = *QuantLibc::OptionletVolatilityStructureHandle_empty;
*asObservable = *QuantLibc::OptionletVolatilityStructureHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_OptionletVolatilityStructureHandle($self);
        delete $OWNER{$self};
    }
}

*referenceDate = *QuantLibc::OptionletVolatilityStructureHandle_referenceDate;
*dayCounter = *QuantLibc::OptionletVolatilityStructureHandle_dayCounter;
*calendar = *QuantLibc::OptionletVolatilityStructureHandle_calendar;
*maxDate = *QuantLibc::OptionletVolatilityStructureHandle_maxDate;
*maxTime = *QuantLibc::OptionletVolatilityStructureHandle_maxTime;
*minStrike = *QuantLibc::OptionletVolatilityStructureHandle_minStrike;
*maxStrike = *QuantLibc::OptionletVolatilityStructureHandle_maxStrike;
*volatility = *QuantLibc::OptionletVolatilityStructureHandle_volatility;
*blackVariance = *QuantLibc::OptionletVolatilityStructureHandle_blackVariance;
*enableExtrapolation = *QuantLibc::OptionletVolatilityStructureHandle_enableExtrapolation;
*disableExtrapolation = *QuantLibc::OptionletVolatilityStructureHandle_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::OptionletVolatilityStructureHandle_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableOptionletVolatilityStructureHandle ##############

package QuantLib::RelinkableOptionletVolatilityStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptionletVolatilityStructureHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableOptionletVolatilityStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableOptionletVolatilityStructureHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableOptionletVolatilityStructureHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SwaptionVolatilityStructure ##############

package QuantLib::SwaptionVolatilityStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::SwaptionVolatilityStructure___deref__;
*isNull = *QuantLibc::SwaptionVolatilityStructure_isNull;
*asObservable = *QuantLibc::SwaptionVolatilityStructure_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SwaptionVolatilityStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SwaptionVolatilityStructure($self);
        delete $OWNER{$self};
    }
}

*referenceDate = *QuantLibc::SwaptionVolatilityStructure_referenceDate;
*dayCounter = *QuantLibc::SwaptionVolatilityStructure_dayCounter;
*calendar = *QuantLibc::SwaptionVolatilityStructure_calendar;
*maxSwapTenor = *QuantLibc::SwaptionVolatilityStructure_maxSwapTenor;
*maxSwapLength = *QuantLibc::SwaptionVolatilityStructure_maxSwapLength;
*minStrike = *QuantLibc::SwaptionVolatilityStructure_minStrike;
*maxStrike = *QuantLibc::SwaptionVolatilityStructure_maxStrike;
*volatility = *QuantLibc::SwaptionVolatilityStructure_volatility;
*blackVariance = *QuantLibc::SwaptionVolatilityStructure_blackVariance;
*optionDateFromTenor = *QuantLibc::SwaptionVolatilityStructure_optionDateFromTenor;
*enableExtrapolation = *QuantLibc::SwaptionVolatilityStructure_enableExtrapolation;
*disableExtrapolation = *QuantLibc::SwaptionVolatilityStructure_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::SwaptionVolatilityStructure_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SwaptionVolatilityStructureHandle ##############

package QuantLib::SwaptionVolatilityStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SwaptionVolatilityStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::SwaptionVolatilityStructureHandle___deref__;
*empty = *QuantLibc::SwaptionVolatilityStructureHandle_empty;
*asObservable = *QuantLibc::SwaptionVolatilityStructureHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SwaptionVolatilityStructureHandle($self);
        delete $OWNER{$self};
    }
}

*referenceDate = *QuantLibc::SwaptionVolatilityStructureHandle_referenceDate;
*dayCounter = *QuantLibc::SwaptionVolatilityStructureHandle_dayCounter;
*calendar = *QuantLibc::SwaptionVolatilityStructureHandle_calendar;
*maxSwapTenor = *QuantLibc::SwaptionVolatilityStructureHandle_maxSwapTenor;
*maxSwapLength = *QuantLibc::SwaptionVolatilityStructureHandle_maxSwapLength;
*minStrike = *QuantLibc::SwaptionVolatilityStructureHandle_minStrike;
*maxStrike = *QuantLibc::SwaptionVolatilityStructureHandle_maxStrike;
*volatility = *QuantLibc::SwaptionVolatilityStructureHandle_volatility;
*blackVariance = *QuantLibc::SwaptionVolatilityStructureHandle_blackVariance;
*optionDateFromTenor = *QuantLibc::SwaptionVolatilityStructureHandle_optionDateFromTenor;
*enableExtrapolation = *QuantLibc::SwaptionVolatilityStructureHandle_enableExtrapolation;
*disableExtrapolation = *QuantLibc::SwaptionVolatilityStructureHandle_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::SwaptionVolatilityStructureHandle_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableSwaptionVolatilityStructureHandle ##############

package QuantLib::RelinkableSwaptionVolatilityStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwaptionVolatilityStructureHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableSwaptionVolatilityStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableSwaptionVolatilityStructureHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableSwaptionVolatilityStructureHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackConstantVol ##############

package QuantLib::BlackConstantVol;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::BlackVolTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackConstantVol(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackConstantVol($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackVarianceCurve ##############

package QuantLib::BlackVarianceCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::BlackVolTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackVarianceCurve(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackVarianceCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackVarianceSurface ##############

package QuantLib::BlackVarianceSurface;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::BlackVolTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackVarianceSurface(@_);
    bless $self, $pkg if defined($self);
}

*setInterpolation = *QuantLibc::BlackVarianceSurface_setInterpolation;
*ConstantExtrapolation = *QuantLibc::BlackVarianceSurface_ConstantExtrapolation;
*ConstantExtrapolation = *QuantLibc::BlackVarianceSurface_ConstantExtrapolation;
*InterpolatorDefaultExtrapolation = *QuantLibc::BlackVarianceSurface_InterpolatorDefaultExtrapolation;
*InterpolatorDefaultExtrapolation = *QuantLibc::BlackVarianceSurface_InterpolatorDefaultExtrapolation;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackVarianceSurface($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LocalConstantVol ##############

package QuantLib::LocalConstantVol;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::LocalVolTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LocalConstantVol(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LocalConstantVol($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LocalVolSurface ##############

package QuantLib::LocalVolSurface;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::LocalVolTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LocalVolSurface(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LocalVolSurface($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ConstantOptionletVolatility ##############

package QuantLib::ConstantOptionletVolatility;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptionletVolatilityStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ConstantOptionletVolatility(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ConstantOptionletVolatility($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ConstantSwaptionVolatility ##############

package QuantLib::ConstantSwaptionVolatility;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwaptionVolatilityStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ConstantSwaptionVolatility(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ConstantSwaptionVolatility($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SwaptionVolatilityMatrix ##############

package QuantLib::SwaptionVolatilityMatrix;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwaptionVolatilityStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SwaptionVolatilityMatrix(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SwaptionVolatilityMatrix($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SwaptionVolCube1 ##############

package QuantLib::SwaptionVolCube1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwaptionVolatilityStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SwaptionVolCube1(@_);
    bless $self, $pkg if defined($self);
}

*sparseSabrParameters = *QuantLibc::SwaptionVolCube1_sparseSabrParameters;
*denseSabrParameters = *QuantLibc::SwaptionVolCube1_denseSabrParameters;
*marketVolCube = *QuantLibc::SwaptionVolCube1_marketVolCube;
*volCubeAtmCalibrated = *QuantLibc::SwaptionVolCube1_volCubeAtmCalibrated;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SwaptionVolCube1($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SwaptionVolCube2 ##############

package QuantLib::SwaptionVolCube2;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::SwaptionVolatilityStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SwaptionVolCube2(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SwaptionVolCube2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::StochasticProcess ##############

package QuantLib::StochasticProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::StochasticProcess___deref__;
*isNull = *QuantLibc::StochasticProcess_isNull;
*asObservable = *QuantLibc::StochasticProcess_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_StochasticProcess(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_StochasticProcess($self);
        delete $OWNER{$self};
    }
}

*size = *QuantLibc::StochasticProcess_size;
*factors = *QuantLibc::StochasticProcess_factors;
*initialValues = *QuantLibc::StochasticProcess_initialValues;
*drift = *QuantLibc::StochasticProcess_drift;
*diffusion = *QuantLibc::StochasticProcess_diffusion;
*expectation = *QuantLibc::StochasticProcess_expectation;
*stdDeviation = *QuantLibc::StochasticProcess_stdDeviation;
*covariance = *QuantLibc::StochasticProcess_covariance;
*evolve = *QuantLibc::StochasticProcess_evolve;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::StochasticProcessVector ##############

package QuantLib::StochasticProcessVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_StochasticProcessVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::StochasticProcessVector_size;
*empty = *QuantLibc::StochasticProcessVector_empty;
*clear = *QuantLibc::StochasticProcessVector_clear;
*push = *QuantLibc::StochasticProcessVector_push;
*pop = *QuantLibc::StochasticProcessVector_pop;
*get = *QuantLibc::StochasticProcessVector_get;
*set = *QuantLibc::StochasticProcessVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_StochasticProcessVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::StochasticProcess1D ##############

package QuantLib::StochasticProcess1D;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::StochasticProcess QuantLib );
%OWNER = ();
%ITERATORS = ();
*x0 = *QuantLibc::StochasticProcess1D_x0;
*drift = *QuantLibc::StochasticProcess1D_drift;
*diffusion = *QuantLibc::StochasticProcess1D_diffusion;
*expectation = *QuantLibc::StochasticProcess1D_expectation;
*stdDeviation = *QuantLibc::StochasticProcess1D_stdDeviation;
*variance = *QuantLibc::StochasticProcess1D_variance;
*evolve = *QuantLibc::StochasticProcess1D_evolve;
*apply = *QuantLibc::StochasticProcess1D_apply;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_StochasticProcess1D($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GeneralizedBlackScholesProcess ##############

package QuantLib::GeneralizedBlackScholesProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::StochasticProcess1D QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GeneralizedBlackScholesProcess(@_);
    bless $self, $pkg if defined($self);
}

*stateVariable = *QuantLibc::GeneralizedBlackScholesProcess_stateVariable;
*dividendYield = *QuantLibc::GeneralizedBlackScholesProcess_dividendYield;
*riskFreeRate = *QuantLibc::GeneralizedBlackScholesProcess_riskFreeRate;
*blackVolatility = *QuantLibc::GeneralizedBlackScholesProcess_blackVolatility;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GeneralizedBlackScholesProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackScholesProcess ##############

package QuantLib::BlackScholesProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::GeneralizedBlackScholesProcess QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackScholesProcess(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackScholesProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackScholesMertonProcess ##############

package QuantLib::BlackScholesMertonProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::GeneralizedBlackScholesProcess QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackScholesMertonProcess(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackScholesMertonProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackProcess ##############

package QuantLib::BlackProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::GeneralizedBlackScholesProcess QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackProcess(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GarmanKohlagenProcess ##############

package QuantLib::GarmanKohlagenProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::GeneralizedBlackScholesProcess QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GarmanKohlagenProcess(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GarmanKohlagenProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Merton76Process ##############

package QuantLib::Merton76Process;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::StochasticProcess1D QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Merton76Process(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Merton76Process($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::StochasticProcessArray ##############

package QuantLib::StochasticProcessArray;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::StochasticProcess QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_StochasticProcessArray(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_StochasticProcessArray($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GeometricBrownianMotionProcess ##############

package QuantLib::GeometricBrownianMotionProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::StochasticProcess1D QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GeometricBrownianMotionProcess(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GeometricBrownianMotionProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::VarianceGammaProcess ##############

package QuantLib::VarianceGammaProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::StochasticProcess1D QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_VarianceGammaProcess(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_VarianceGammaProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HestonProcess ##############

package QuantLib::HestonProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::StochasticProcess QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HestonProcess(@_);
    bless $self, $pkg if defined($self);
}

*s0 = *QuantLibc::HestonProcess_s0;
*dividendYield = *QuantLibc::HestonProcess_dividendYield;
*riskFreeRate = *QuantLibc::HestonProcess_riskFreeRate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HestonProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BatesProcess ##############

package QuantLib::BatesProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::HestonProcess QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BatesProcess(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BatesProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HullWhiteProcess ##############

package QuantLib::HullWhiteProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::StochasticProcess1D QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HullWhiteProcess(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HullWhiteProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HullWhiteForwardProcess ##############

package QuantLib::HullWhiteForwardProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::StochasticProcess1D QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HullWhiteForwardProcess(@_);
    bless $self, $pkg if defined($self);
}

*alpha = *QuantLibc::HullWhiteForwardProcess_alpha;
*M_T = *QuantLibc::HullWhiteForwardProcess_M_T;
*B = *QuantLibc::HullWhiteForwardProcess_B;
*setForwardMeasureTime = *QuantLibc::HullWhiteForwardProcess_setForwardMeasureTime;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HullWhiteForwardProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GsrProcess ##############

package QuantLib::GsrProcess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::StochasticProcess1D QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GsrProcess(@_);
    bless $self, $pkg if defined($self);
}

*sigma = *QuantLibc::GsrProcess_sigma;
*reversion = *QuantLibc::GsrProcess_reversion;
*y = *QuantLibc::GsrProcess_y;
*G = *QuantLibc::GsrProcess_G;
*setForwardMeasureTime = *QuantLibc::GsrProcess_setForwardMeasureTime;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GsrProcess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PricingEngine ##############

package QuantLib::PricingEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::PricingEngine___deref__;
*isNull = *QuantLibc::PricingEngine_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PricingEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PricingEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Instrument ##############

package QuantLib::Instrument;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::Instrument___deref__;
*isNull = *QuantLibc::Instrument_isNull;
*asObservable = *QuantLibc::Instrument_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Instrument(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Instrument($self);
        delete $OWNER{$self};
    }
}

*NPV = *QuantLibc::Instrument_NPV;
*errorEstimate = *QuantLibc::Instrument_errorEstimate;
*isExpired = *QuantLibc::Instrument_isExpired;
*setPricingEngine = *QuantLibc::Instrument_setPricingEngine;
*recalculate = *QuantLibc::Instrument_recalculate;
*freeze = *QuantLibc::Instrument_freeze;
*unfreeze = *QuantLibc::Instrument_unfreeze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InstrumentVector ##############

package QuantLib::InstrumentVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InstrumentVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::InstrumentVector_size;
*empty = *QuantLibc::InstrumentVector_empty;
*clear = *QuantLibc::InstrumentVector_clear;
*push = *QuantLibc::InstrumentVector_push;
*pop = *QuantLibc::InstrumentVector_pop;
*get = *QuantLibc::InstrumentVector_get;
*set = *QuantLibc::InstrumentVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InstrumentVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Stock ##############

package QuantLib::Stock;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Stock(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Stock($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CompositeInstrument ##############

package QuantLib::CompositeInstrument;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CompositeInstrument(@_);
    bless $self, $pkg if defined($self);
}

*add = *QuantLibc::CompositeInstrument_add;
*subtract = *QuantLibc::CompositeInstrument_subtract;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CompositeInstrument($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DateGeneration ##############

package QuantLib::DateGeneration;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Backward = *QuantLibc::DateGeneration_Backward;
*Forward = *QuantLibc::DateGeneration_Forward;
*Zero = *QuantLibc::DateGeneration_Zero;
*ThirdWednesday = *QuantLibc::DateGeneration_ThirdWednesday;
*Twentieth = *QuantLibc::DateGeneration_Twentieth;
*TwentiethIMM = *QuantLibc::DateGeneration_TwentiethIMM;
*OldCDS = *QuantLibc::DateGeneration_OldCDS;
*CDS = *QuantLibc::DateGeneration_CDS;
*CDS2015 = *QuantLibc::DateGeneration_CDS2015;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DateGeneration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DateGeneration($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Schedule ##############

package QuantLib::Schedule;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Schedule(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::Schedule_size;
*date = *QuantLibc::Schedule_date;
*isRegular = *QuantLibc::Schedule_isRegular;
*until = *QuantLibc::Schedule_until;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Schedule($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MakeSchedule ##############

package QuantLib::MakeSchedule;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MakeSchedule(@_);
    bless $self, $pkg if defined($self);
}

*from = *QuantLibc::MakeSchedule_from;
*to = *QuantLibc::MakeSchedule_to;
*withTenor = *QuantLibc::MakeSchedule_withTenor;
*withFrequency = *QuantLibc::MakeSchedule_withFrequency;
*withCalendar = *QuantLibc::MakeSchedule_withCalendar;
*withConvention = *QuantLibc::MakeSchedule_withConvention;
*withTerminationDateConvention = *QuantLibc::MakeSchedule_withTerminationDateConvention;
*withRule = *QuantLibc::MakeSchedule_withRule;
*forwards = *QuantLibc::MakeSchedule_forwards;
*backwards = *QuantLibc::MakeSchedule_backwards;
*endOfMonth = *QuantLibc::MakeSchedule_endOfMonth;
*withFirstDate = *QuantLibc::MakeSchedule_withFirstDate;
*withNextToLastDate = *QuantLibc::MakeSchedule_withNextToLastDate;
*schedule = *QuantLibc::MakeSchedule_schedule;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MakeSchedule($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CashFlow ##############

package QuantLib::CashFlow;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::CashFlow___deref__;
*isNull = *QuantLibc::CashFlow_isNull;
*asObservable = *QuantLibc::CashFlow_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CashFlow(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CashFlow($self);
        delete $OWNER{$self};
    }
}

*amount = *QuantLibc::CashFlow_amount;
*date = *QuantLibc::CashFlow_date;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Leg ##############

package QuantLib::Leg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Leg(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::Leg_size;
*empty = *QuantLibc::Leg_empty;
*clear = *QuantLibc::Leg_clear;
*push = *QuantLibc::Leg_push;
*pop = *QuantLibc::Leg_pop;
*get = *QuantLibc::Leg_get;
*set = *QuantLibc::Leg_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Leg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SimpleCashFlow ##############

package QuantLib::SimpleCashFlow;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CashFlow QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SimpleCashFlow(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SimpleCashFlow($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Redemption ##############

package QuantLib::Redemption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CashFlow QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Redemption(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Redemption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AmortizingPayment ##############

package QuantLib::AmortizingPayment;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CashFlow QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AmortizingPayment(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AmortizingPayment($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Coupon ##############

package QuantLib::Coupon;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CashFlow QuantLib );
%OWNER = ();
%ITERATORS = ();
*nominal = *QuantLibc::Coupon_nominal;
*accrualStartDate = *QuantLibc::Coupon_accrualStartDate;
*accrualEndDate = *QuantLibc::Coupon_accrualEndDate;
*referencePeriodStart = *QuantLibc::Coupon_referencePeriodStart;
*referencePeriodEnd = *QuantLibc::Coupon_referencePeriodEnd;
*exCouponDate = *QuantLibc::Coupon_exCouponDate;
*rate = *QuantLibc::Coupon_rate;
*accrualPeriod = *QuantLibc::Coupon_accrualPeriod;
*accrualDays = *QuantLibc::Coupon_accrualDays;
*dayCounter = *QuantLibc::Coupon_dayCounter;
*accruedAmount = *QuantLibc::Coupon_accruedAmount;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Coupon($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FixedRateCoupon ##############

package QuantLib::FixedRateCoupon;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Coupon QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FixedRateCoupon(@_);
    bless $self, $pkg if defined($self);
}

*interestRate = *QuantLibc::FixedRateCoupon_interestRate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FixedRateCoupon($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FloatingRateCouponPricer ##############

package QuantLib::FloatingRateCouponPricer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::FloatingRateCouponPricer___deref__;
*isNull = *QuantLibc::FloatingRateCouponPricer_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FloatingRateCouponPricer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FloatingRateCouponPricer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FloatingRateCoupon ##############

package QuantLib::FloatingRateCoupon;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Coupon QuantLib );
%OWNER = ();
%ITERATORS = ();
*fixingDate = *QuantLibc::FloatingRateCoupon_fixingDate;
*fixingDays = *QuantLibc::FloatingRateCoupon_fixingDays;
*isInArrears = *QuantLibc::FloatingRateCoupon_isInArrears;
*gearing = *QuantLibc::FloatingRateCoupon_gearing;
*spread = *QuantLibc::FloatingRateCoupon_spread;
*indexFixing = *QuantLibc::FloatingRateCoupon_indexFixing;
*adjustedFixing = *QuantLibc::FloatingRateCoupon_adjustedFixing;
*convexityAdjustment = *QuantLibc::FloatingRateCoupon_convexityAdjustment;
*price = *QuantLibc::FloatingRateCoupon_price;
*index = *QuantLibc::FloatingRateCoupon_index;
*setPricer = *QuantLibc::FloatingRateCoupon_setPricer;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FloatingRateCoupon($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CappedFlooredCoupon ##############

package QuantLib::CappedFlooredCoupon;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::FloatingRateCoupon QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CappedFlooredCoupon(@_);
    bless $self, $pkg if defined($self);
}

*cap = *QuantLibc::CappedFlooredCoupon_cap;
*floor = *QuantLibc::CappedFlooredCoupon_floor;
*effectiveCap = *QuantLibc::CappedFlooredCoupon_effectiveCap;
*effectiveFloor = *QuantLibc::CappedFlooredCoupon_effectiveFloor;
*isCapped = *QuantLibc::CappedFlooredCoupon_isCapped;
*isFloored = *QuantLibc::CappedFlooredCoupon_isFloored;
*setPricer = *QuantLibc::CappedFlooredCoupon_setPricer;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CappedFlooredCoupon($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IborCoupon ##############

package QuantLib::IborCoupon;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::FloatingRateCoupon QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IborCoupon(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IborCoupon($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IborCouponPricer ##############

package QuantLib::IborCouponPricer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::FloatingRateCouponPricer QuantLib );
%OWNER = ();
%ITERATORS = ();
*capletVolatility = *QuantLibc::IborCouponPricer_capletVolatility;
*setCapletVolatility = *QuantLibc::IborCouponPricer_setCapletVolatility;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IborCouponPricer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackIborCouponPricer ##############

package QuantLib::BlackIborCouponPricer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::IborCouponPricer QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackIborCouponPricer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackIborCouponPricer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CmsCoupon ##############

package QuantLib::CmsCoupon;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::FloatingRateCoupon QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CmsCoupon(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CmsCoupon($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CmsCouponPricer ##############

package QuantLib::CmsCouponPricer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::FloatingRateCouponPricer QuantLib );
%OWNER = ();
%ITERATORS = ();
*swaptionVolatility = *QuantLibc::CmsCouponPricer_swaptionVolatility;
*setSwaptionVolatility = *QuantLibc::CmsCouponPricer_setSwaptionVolatility;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CmsCouponPricer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GFunctionFactory ##############

package QuantLib::GFunctionFactory;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Standard = *QuantLibc::GFunctionFactory_Standard;
*ExactYield = *QuantLibc::GFunctionFactory_ExactYield;
*ParallelShifts = *QuantLibc::GFunctionFactory_ParallelShifts;
*NonParallelShifts = *QuantLibc::GFunctionFactory_NonParallelShifts;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GFunctionFactory($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticHaganPricer ##############

package QuantLib::AnalyticHaganPricer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CmsCouponPricer QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticHaganPricer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticHaganPricer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NumericHaganPricer ##############

package QuantLib::NumericHaganPricer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CmsCouponPricer QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NumericHaganPricer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NumericHaganPricer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CappedFlooredCmsCoupon ##############

package QuantLib::CappedFlooredCmsCoupon;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CappedFlooredCoupon QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CappedFlooredCmsCoupon(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CappedFlooredCmsCoupon($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LinearTsrPricer ##############

package QuantLib::LinearTsrPricer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CmsCouponPricer QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LinearTsrPricer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LinearTsrPricer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Duration ##############

package QuantLib::Duration;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Simple = *QuantLibc::Duration_Simple;
*Macaulay = *QuantLibc::Duration_Macaulay;
*Modified = *QuantLibc::Duration_Modified;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Duration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Duration($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CashFlows ##############

package QuantLib::CashFlows;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*startDate = *QuantLibc::CashFlows_startDate;
*maturityDate = *QuantLibc::CashFlows_maturityDate;
*previousCashFlowDate = *QuantLibc::CashFlows_previousCashFlowDate;
*nextCashFlowDate = *QuantLibc::CashFlows_nextCashFlowDate;
*npv = *QuantLibc::CashFlows_npv;
*bps = *QuantLibc::CashFlows_bps;
*atmRate = *QuantLibc::CashFlows_atmRate;
*yield = *QuantLibc::CashFlows_yield;
*duration = *QuantLibc::CashFlows_duration;
*convexity = *QuantLibc::CashFlows_convexity;
*basisPointValue = *QuantLibc::CashFlows_basisPointValue;
*zSpread = *QuantLibc::CashFlows_zSpread;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CashFlows($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CalibrationHelper ##############

package QuantLib::CalibrationHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::CalibrationHelper___deref__;
*isNull = *QuantLibc::CalibrationHelper_isNull;
*RelativePriceError = *QuantLibc::CalibrationHelper_RelativePriceError;
*RelativePriceError = *QuantLibc::CalibrationHelper_RelativePriceError;
*PriceError = *QuantLibc::CalibrationHelper_PriceError;
*PriceError = *QuantLibc::CalibrationHelper_PriceError;
*ImpliedVolError = *QuantLibc::CalibrationHelper_ImpliedVolError;
*ImpliedVolError = *QuantLibc::CalibrationHelper_ImpliedVolError;
*swaptionExpiryDate = *QuantLibc::CalibrationHelper_swaptionExpiryDate;
*swaptionStrike = *QuantLibc::CalibrationHelper_swaptionStrike;
*swaptionNominal = *QuantLibc::CalibrationHelper_swaptionNominal;
*swaptionMaturityDate = *QuantLibc::CalibrationHelper_swaptionMaturityDate;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CalibrationHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CalibrationHelper($self);
        delete $OWNER{$self};
    }
}

*setPricingEngine = *QuantLibc::CalibrationHelper_setPricingEngine;
*marketValue = *QuantLibc::CalibrationHelper_marketValue;
*modelValue = *QuantLibc::CalibrationHelper_modelValue;
*calibrationError = *QuantLibc::CalibrationHelper_calibrationError;
*impliedVolatility = *QuantLibc::CalibrationHelper_impliedVolatility;
*blackPrice = *QuantLibc::CalibrationHelper_blackPrice;
*volatility = *QuantLibc::CalibrationHelper_volatility;
*volatilityType = *QuantLibc::CalibrationHelper_volatilityType;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SwaptionHelper ##############

package QuantLib::SwaptionHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CalibrationHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SwaptionHelper(@_);
    bless $self, $pkg if defined($self);
}

*times = *QuantLibc::SwaptionHelper_times;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SwaptionHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CapHelper ##############

package QuantLib::CapHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CalibrationHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CapHelper(@_);
    bless $self, $pkg if defined($self);
}

*times = *QuantLibc::CapHelper_times;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CapHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HestonModelHelper ##############

package QuantLib::HestonModelHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CalibrationHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HestonModelHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HestonModelHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CalibrationHelperVector ##############

package QuantLib::CalibrationHelperVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CalibrationHelperVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::CalibrationHelperVector_size;
*empty = *QuantLibc::CalibrationHelperVector_empty;
*clear = *QuantLibc::CalibrationHelperVector_clear;
*push = *QuantLibc::CalibrationHelperVector_push;
*pop = *QuantLibc::CalibrationHelperVector_pop;
*get = *QuantLibc::CalibrationHelperVector_get;
*set = *QuantLibc::CalibrationHelperVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CalibrationHelperVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CalibratedModel ##############

package QuantLib::CalibratedModel;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::CalibratedModel___deref__;
*isNull = *QuantLibc::CalibratedModel_isNull;
*asObservable = *QuantLibc::CalibratedModel_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CalibratedModel(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CalibratedModel($self);
        delete $OWNER{$self};
    }
}

*params = *QuantLibc::CalibratedModel_params;
*calibrate = *QuantLibc::CalibratedModel_calibrate;
*setParams = *QuantLibc::CalibratedModel_setParams;
*value = *QuantLibc::CalibratedModel_value;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CalibratedModelHandle ##############

package QuantLib::CalibratedModelHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CalibratedModelHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::CalibratedModelHandle___deref__;
*empty = *QuantLibc::CalibratedModelHandle_empty;
*asObservable = *QuantLibc::CalibratedModelHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CalibratedModelHandle($self);
        delete $OWNER{$self};
    }
}

*params = *QuantLibc::CalibratedModelHandle_params;
*calibrate = *QuantLibc::CalibratedModelHandle_calibrate;
*setParams = *QuantLibc::CalibratedModelHandle_setParams;
*value = *QuantLibc::CalibratedModelHandle_value;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableCalibratedModelHandle ##############

package QuantLib::RelinkableCalibratedModelHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CalibratedModelHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableCalibratedModelHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableCalibratedModelHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableCalibratedModelHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TimeGrid ##############

package QuantLib::TimeGrid;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TimeGrid(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::TimeGrid_size;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TimeGrid($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Parameter ##############

package QuantLib::Parameter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Parameter(@_);
    bless $self, $pkg if defined($self);
}

*params = *QuantLibc::Parameter_params;
*setParam = *QuantLibc::Parameter_setParam;
*testParams = *QuantLibc::Parameter_testParams;
*size = *QuantLibc::Parameter_size;
*__call__ = *QuantLibc::Parameter___call__;
*constraint = *QuantLibc::Parameter_constraint;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Parameter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ConstantParameter ##############

package QuantLib::ConstantParameter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Parameter QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ConstantParameter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ConstantParameter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NullParameter ##############

package QuantLib::NullParameter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Parameter QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NullParameter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NullParameter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PiecewiseConstantParameter ##############

package QuantLib::PiecewiseConstantParameter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Parameter QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PiecewiseConstantParameter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PiecewiseConstantParameter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Option ##############

package QuantLib::Option;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Put = *QuantLibc::Option_Put;
*Call = *QuantLibc::Option_Call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Option($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Barrier ##############

package QuantLib::Barrier;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*DownIn = *QuantLibc::Barrier_DownIn;
*UpIn = *QuantLibc::Barrier_UpIn;
*DownOut = *QuantLibc::Barrier_DownOut;
*UpOut = *QuantLibc::Barrier_UpOut;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Barrier(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Barrier($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DoubleBarrier ##############

package QuantLib::DoubleBarrier;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*KnockIn = *QuantLibc::DoubleBarrier_KnockIn;
*KnockOut = *QuantLibc::DoubleBarrier_KnockOut;
*KIKO = *QuantLibc::DoubleBarrier_KIKO;
*KOKI = *QuantLibc::DoubleBarrier_KOKI;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DoubleBarrier(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DoubleBarrier($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Payoff ##############

package QuantLib::Payoff;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::Payoff___deref__;
*isNull = *QuantLibc::Payoff_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Payoff(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Payoff($self);
        delete $OWNER{$self};
    }
}

*call = *QuantLibc::Payoff_call;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::VanillaOption ##############

package QuantLib::VanillaOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_VanillaOption(@_);
    bless $self, $pkg if defined($self);
}

*priceCurve = *QuantLibc::VanillaOption_priceCurve;
*impliedVolatility = *QuantLibc::VanillaOption_impliedVolatility;
*delta = *QuantLibc::VanillaOption_delta;
*gamma = *QuantLibc::VanillaOption_gamma;
*theta = *QuantLibc::VanillaOption_theta;
*thetaPerDay = *QuantLibc::VanillaOption_thetaPerDay;
*vega = *QuantLibc::VanillaOption_vega;
*rho = *QuantLibc::VanillaOption_rho;
*dividendRho = *QuantLibc::VanillaOption_dividendRho;
*strikeSensitivity = *QuantLibc::VanillaOption_strikeSensitivity;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_VanillaOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EuropeanOption ##############

package QuantLib::EuropeanOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::VanillaOption QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EuropeanOption(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EuropeanOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ForwardVanillaOption ##############

package QuantLib::ForwardVanillaOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::VanillaOption QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ForwardVanillaOption(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ForwardVanillaOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::QuantoVanillaOption ##############

package QuantLib::QuantoVanillaOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::VanillaOption QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_QuantoVanillaOption(@_);
    bless $self, $pkg if defined($self);
}

*qvega = *QuantLibc::QuantoVanillaOption_qvega;
*qrho = *QuantLibc::QuantoVanillaOption_qrho;
*qlambda = *QuantLibc::QuantoVanillaOption_qlambda;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_QuantoVanillaOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::QuantoForwardVanillaOption ##############

package QuantLib::QuantoForwardVanillaOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::QuantoVanillaOption QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_QuantoForwardVanillaOption(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_QuantoForwardVanillaOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MultiAssetOption ##############

package QuantLib::MultiAssetOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
*delta = *QuantLibc::MultiAssetOption_delta;
*gamma = *QuantLibc::MultiAssetOption_gamma;
*theta = *QuantLibc::MultiAssetOption_theta;
*vega = *QuantLibc::MultiAssetOption_vega;
*rho = *QuantLibc::MultiAssetOption_rho;
*dividendRho = *QuantLibc::MultiAssetOption_dividendRho;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MultiAssetOption(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MultiAssetOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticEuropeanEngine ##############

package QuantLib::AnalyticEuropeanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticEuropeanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticEuropeanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HestonModel ##############

package QuantLib::HestonModel;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CalibratedModel QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HestonModel(@_);
    bless $self, $pkg if defined($self);
}

*theta = *QuantLibc::HestonModel_theta;
*kappa = *QuantLibc::HestonModel_kappa;
*sigma = *QuantLibc::HestonModel_sigma;
*rho = *QuantLibc::HestonModel_rho;
*v0 = *QuantLibc::HestonModel_v0;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HestonModel($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PiecewiseTimeDependentHestonModel ##############

package QuantLib::PiecewiseTimeDependentHestonModel;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CalibratedModel QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PiecewiseTimeDependentHestonModel(@_);
    bless $self, $pkg if defined($self);
}

*theta = *QuantLibc::PiecewiseTimeDependentHestonModel_theta;
*kappa = *QuantLibc::PiecewiseTimeDependentHestonModel_kappa;
*sigma = *QuantLibc::PiecewiseTimeDependentHestonModel_sigma;
*rho = *QuantLibc::PiecewiseTimeDependentHestonModel_rho;
*v0 = *QuantLibc::PiecewiseTimeDependentHestonModel_v0;
*s0 = *QuantLibc::PiecewiseTimeDependentHestonModel_s0;
*timeGrid = *QuantLibc::PiecewiseTimeDependentHestonModel_timeGrid;
*dividendYield = *QuantLibc::PiecewiseTimeDependentHestonModel_dividendYield;
*riskFreeRate = *QuantLibc::PiecewiseTimeDependentHestonModel_riskFreeRate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PiecewiseTimeDependentHestonModel($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticHestonEngine ##############

package QuantLib::AnalyticHestonEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticHestonEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticHestonEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticPTDHestonEngine ##############

package QuantLib::AnalyticPTDHestonEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticPTDHestonEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticPTDHestonEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BatesModel ##############

package QuantLib::BatesModel;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::HestonModel QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BatesModel(@_);
    bless $self, $pkg if defined($self);
}

*nu = *QuantLibc::BatesModel_nu;
*delta = *QuantLibc::BatesModel_delta;
*lambda = *QuantLibc::BatesModel_lambda;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BatesModel($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BatesEngine ##############

package QuantLib::BatesEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BatesEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BatesEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IntegralEngine ##############

package QuantLib::IntegralEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IntegralEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IntegralEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FDBermudanEngine ##############

package QuantLib::FDBermudanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FDBermudanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FDBermudanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FDEuropeanEngine ##############

package QuantLib::FDEuropeanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FDEuropeanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FDEuropeanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BinomialVanillaEngine ##############

package QuantLib::BinomialVanillaEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BinomialVanillaEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BinomialVanillaEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LsmBasisSystem ##############

package QuantLib::LsmBasisSystem;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Monomial = *QuantLibc::LsmBasisSystem_Monomial;
*Laguerre = *QuantLibc::LsmBasisSystem_Laguerre;
*Hermite = *QuantLibc::LsmBasisSystem_Hermite;
*Hyperbolic = *QuantLibc::LsmBasisSystem_Hyperbolic;
*Legendre = *QuantLibc::LsmBasisSystem_Legendre;
*Chebyshev = *QuantLibc::LsmBasisSystem_Chebyshev;
*Chebyshev2nd = *QuantLibc::LsmBasisSystem_Chebyshev2nd;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LsmBasisSystem(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LsmBasisSystem($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MCEuropeanEngine ##############

package QuantLib::MCEuropeanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MCEuropeanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MCEuropeanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MCAmericanEngine ##############

package QuantLib::MCAmericanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
*Receiver = *QuantLibc::MCAmericanEngine_Receiver;
*Receiver = *QuantLibc::MCAmericanEngine_Receiver;
*Payer = *QuantLibc::MCAmericanEngine_Payer;
*Payer = *QuantLibc::MCAmericanEngine_Payer;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MCAmericanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MCAmericanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FDAmericanEngine ##############

package QuantLib::FDAmericanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FDAmericanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FDAmericanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FdBlackScholesVanillaEngine ##############

package QuantLib::FdBlackScholesVanillaEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FdBlackScholesVanillaEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FdBlackScholesVanillaEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FdBatesVanillaEngine ##############

package QuantLib::FdBatesVanillaEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FdBatesVanillaEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FdBatesVanillaEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ContinuousArithmeticAsianLevyEngine ##############

package QuantLib::ContinuousArithmeticAsianLevyEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ContinuousArithmeticAsianLevyEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ContinuousArithmeticAsianLevyEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FdBlackScholesAsianEngine ##############

package QuantLib::FdBlackScholesAsianEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FdBlackScholesAsianEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FdBlackScholesAsianEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FDShoutEngine ##############

package QuantLib::FDShoutEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FDShoutEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FDShoutEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BaroneAdesiWhaleyEngine ##############

package QuantLib::BaroneAdesiWhaleyEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BaroneAdesiWhaleyEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BaroneAdesiWhaleyEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BjerksundStenslandEngine ##############

package QuantLib::BjerksundStenslandEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BjerksundStenslandEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BjerksundStenslandEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticDigitalAmericanEngine ##############

package QuantLib::AnalyticDigitalAmericanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticDigitalAmericanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticDigitalAmericanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticDigitalAmericanKOEngine ##############

package QuantLib::AnalyticDigitalAmericanKOEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticDigitalAmericanKOEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticDigitalAmericanKOEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DividendVanillaOption ##############

package QuantLib::DividendVanillaOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DividendVanillaOption(@_);
    bless $self, $pkg if defined($self);
}

*priceCurve = *QuantLibc::DividendVanillaOption_priceCurve;
*impliedVolatility = *QuantLibc::DividendVanillaOption_impliedVolatility;
*delta = *QuantLibc::DividendVanillaOption_delta;
*gamma = *QuantLibc::DividendVanillaOption_gamma;
*theta = *QuantLibc::DividendVanillaOption_theta;
*thetaPerDay = *QuantLibc::DividendVanillaOption_thetaPerDay;
*vega = *QuantLibc::DividendVanillaOption_vega;
*rho = *QuantLibc::DividendVanillaOption_rho;
*dividendRho = *QuantLibc::DividendVanillaOption_dividendRho;
*strikeSensitivity = *QuantLibc::DividendVanillaOption_strikeSensitivity;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DividendVanillaOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticDividendEuropeanEngine ##############

package QuantLib::AnalyticDividendEuropeanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticDividendEuropeanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticDividendEuropeanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FDDividendEuropeanEngine ##############

package QuantLib::FDDividendEuropeanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FDDividendEuropeanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FDDividendEuropeanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FDDividendAmericanEngine ##############

package QuantLib::FDDividendAmericanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FDDividendAmericanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FDDividendAmericanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BarrierOption ##############

package QuantLib::BarrierOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BarrierOption(@_);
    bless $self, $pkg if defined($self);
}

*priceCurve = *QuantLibc::BarrierOption_priceCurve;
*impliedVolatility = *QuantLibc::BarrierOption_impliedVolatility;
*delta = *QuantLibc::BarrierOption_delta;
*gamma = *QuantLibc::BarrierOption_gamma;
*theta = *QuantLibc::BarrierOption_theta;
*thetaPerDay = *QuantLibc::BarrierOption_thetaPerDay;
*vega = *QuantLibc::BarrierOption_vega;
*rho = *QuantLibc::BarrierOption_rho;
*dividendRho = *QuantLibc::BarrierOption_dividendRho;
*strikeSensitivity = *QuantLibc::BarrierOption_strikeSensitivity;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BarrierOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticBarrierEngine ##############

package QuantLib::AnalyticBarrierEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticBarrierEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticBarrierEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MCBarrierEngine ##############

package QuantLib::MCBarrierEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MCBarrierEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MCBarrierEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FdmSchemeDesc ##############

package QuantLib::FdmSchemeDesc;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*HundsdorferType = *QuantLibc::FdmSchemeDesc_HundsdorferType;
*DouglasType = *QuantLibc::FdmSchemeDesc_DouglasType;
*CraigSneydType = *QuantLibc::FdmSchemeDesc_CraigSneydType;
*ModifiedCraigSneydType = *QuantLibc::FdmSchemeDesc_ModifiedCraigSneydType;
*ImplicitEulerType = *QuantLibc::FdmSchemeDesc_ImplicitEulerType;
*ExplicitEulerType = *QuantLibc::FdmSchemeDesc_ExplicitEulerType;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FdmSchemeDesc(@_);
    bless $self, $pkg if defined($self);
}

*swig_type_get = *QuantLibc::FdmSchemeDesc_type_get;
*swig_type_set = *QuantLibc::FdmSchemeDesc_type_set;
*swig_theta_get = *QuantLibc::FdmSchemeDesc_theta_get;
*swig_theta_set = *QuantLibc::FdmSchemeDesc_theta_set;
*swig_mu_get = *QuantLibc::FdmSchemeDesc_mu_get;
*swig_mu_set = *QuantLibc::FdmSchemeDesc_mu_set;
*Douglas = *QuantLibc::FdmSchemeDesc_Douglas;
*ImplicitEuler = *QuantLibc::FdmSchemeDesc_ImplicitEuler;
*ExplicitEuler = *QuantLibc::FdmSchemeDesc_ExplicitEuler;
*CraigSneyd = *QuantLibc::FdmSchemeDesc_CraigSneyd;
*ModifiedCraigSneyd = *QuantLibc::FdmSchemeDesc_ModifiedCraigSneyd;
*Hundsdorfer = *QuantLibc::FdmSchemeDesc_Hundsdorfer;
*ModifiedHundsdorfer = *QuantLibc::FdmSchemeDesc_ModifiedHundsdorfer;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FdmSchemeDesc($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FdBlackScholesBarrierEngine ##############

package QuantLib::FdBlackScholesBarrierEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FdBlackScholesBarrierEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FdBlackScholesBarrierEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticBinaryBarrierEngine ##############

package QuantLib::AnalyticBinaryBarrierEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticBinaryBarrierEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticBinaryBarrierEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BinomialBarrierEngine ##############

package QuantLib::BinomialBarrierEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BinomialBarrierEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BinomialBarrierEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ForwardEuropeanEngine ##############

package QuantLib::ForwardEuropeanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ForwardEuropeanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ForwardEuropeanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::QuantoEuropeanEngine ##############

package QuantLib::QuantoEuropeanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_QuantoEuropeanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_QuantoEuropeanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::QuantoForwardEuropeanEngine ##############

package QuantLib::QuantoForwardEuropeanEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_QuantoForwardEuropeanEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_QuantoForwardEuropeanEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackCalculator ##############

package QuantLib::BlackCalculator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackCalculator(@_);
    bless $self, $pkg if defined($self);
}

*value = *QuantLibc::BlackCalculator_value;
*deltaForward = *QuantLibc::BlackCalculator_deltaForward;
*delta = *QuantLibc::BlackCalculator_delta;
*elasticityForward = *QuantLibc::BlackCalculator_elasticityForward;
*elasticity = *QuantLibc::BlackCalculator_elasticity;
*gammaForward = *QuantLibc::BlackCalculator_gammaForward;
*gamma = *QuantLibc::BlackCalculator_gamma;
*theta = *QuantLibc::BlackCalculator_theta;
*thetaPerDay = *QuantLibc::BlackCalculator_thetaPerDay;
*vega = *QuantLibc::BlackCalculator_vega;
*rho = *QuantLibc::BlackCalculator_rho;
*dividendRho = *QuantLibc::BlackCalculator_dividendRho;
*itmCashProbability = *QuantLibc::BlackCalculator_itmCashProbability;
*itmAssetProbability = *QuantLibc::BlackCalculator_itmAssetProbability;
*strikeSensitivity = *QuantLibc::BlackCalculator_strikeSensitivity;
*alpha = *QuantLibc::BlackCalculator_alpha;
*beta = *QuantLibc::BlackCalculator_beta;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackCalculator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Average ##############

package QuantLib::Average;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Arithmetic = *QuantLibc::Average_Arithmetic;
*Geometric = *QuantLibc::Average_Geometric;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Average(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Average($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ContinuousAveragingAsianOption ##############

package QuantLib::ContinuousAveragingAsianOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ContinuousAveragingAsianOption(@_);
    bless $self, $pkg if defined($self);
}

*delta = *QuantLibc::ContinuousAveragingAsianOption_delta;
*gamma = *QuantLibc::ContinuousAveragingAsianOption_gamma;
*theta = *QuantLibc::ContinuousAveragingAsianOption_theta;
*thetaPerDay = *QuantLibc::ContinuousAveragingAsianOption_thetaPerDay;
*vega = *QuantLibc::ContinuousAveragingAsianOption_vega;
*rho = *QuantLibc::ContinuousAveragingAsianOption_rho;
*dividendRho = *QuantLibc::ContinuousAveragingAsianOption_dividendRho;
*strikeSensitivity = *QuantLibc::ContinuousAveragingAsianOption_strikeSensitivity;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ContinuousAveragingAsianOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DiscreteAveragingAsianOption ##############

package QuantLib::DiscreteAveragingAsianOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DiscreteAveragingAsianOption(@_);
    bless $self, $pkg if defined($self);
}

*delta = *QuantLibc::DiscreteAveragingAsianOption_delta;
*gamma = *QuantLibc::DiscreteAveragingAsianOption_gamma;
*theta = *QuantLibc::DiscreteAveragingAsianOption_theta;
*thetaPerDay = *QuantLibc::DiscreteAveragingAsianOption_thetaPerDay;
*vega = *QuantLibc::DiscreteAveragingAsianOption_vega;
*rho = *QuantLibc::DiscreteAveragingAsianOption_rho;
*dividendRho = *QuantLibc::DiscreteAveragingAsianOption_dividendRho;
*strikeSensitivity = *QuantLibc::DiscreteAveragingAsianOption_strikeSensitivity;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DiscreteAveragingAsianOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticContinuousGeometricAveragePriceAsianEngine ##############

package QuantLib::AnalyticContinuousGeometricAveragePriceAsianEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticContinuousGeometricAveragePriceAsianEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticContinuousGeometricAveragePriceAsianEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticDiscreteGeometricAveragePriceAsianEngine ##############

package QuantLib::AnalyticDiscreteGeometricAveragePriceAsianEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticDiscreteGeometricAveragePriceAsianEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticDiscreteGeometricAveragePriceAsianEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticDiscreteGeometricAverageStrikeAsianEngine ##############

package QuantLib::AnalyticDiscreteGeometricAverageStrikeAsianEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticDiscreteGeometricAverageStrikeAsianEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticDiscreteGeometricAverageStrikeAsianEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MCDiscreteArithmeticAPEngine ##############

package QuantLib::MCDiscreteArithmeticAPEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MCDiscreteArithmeticAPEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MCDiscreteArithmeticAPEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MCDiscreteArithmeticASEngine ##############

package QuantLib::MCDiscreteArithmeticASEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MCDiscreteArithmeticASEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MCDiscreteArithmeticASEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MCDiscreteGeometricAPEngine ##############

package QuantLib::MCDiscreteGeometricAPEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MCDiscreteGeometricAPEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MCDiscreteGeometricAPEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::VarianceGammaEngine ##############

package QuantLib::VarianceGammaEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_VarianceGammaEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_VarianceGammaEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FFTVarianceGammaEngine ##############

package QuantLib::FFTVarianceGammaEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FFTVarianceGammaEngine(@_);
    bless $self, $pkg if defined($self);
}

*precalculate = *QuantLibc::FFTVarianceGammaEngine_precalculate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FFTVarianceGammaEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DoubleBarrierOption ##############

package QuantLib::DoubleBarrierOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DoubleBarrierOption(@_);
    bless $self, $pkg if defined($self);
}

*delta = *QuantLibc::DoubleBarrierOption_delta;
*gamma = *QuantLibc::DoubleBarrierOption_gamma;
*theta = *QuantLibc::DoubleBarrierOption_theta;
*thetaPerDay = *QuantLibc::DoubleBarrierOption_thetaPerDay;
*vega = *QuantLibc::DoubleBarrierOption_vega;
*rho = *QuantLibc::DoubleBarrierOption_rho;
*dividendRho = *QuantLibc::DoubleBarrierOption_dividendRho;
*strikeSensitivity = *QuantLibc::DoubleBarrierOption_strikeSensitivity;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DoubleBarrierOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::QuantoDoubleBarrierOption ##############

package QuantLib::QuantoDoubleBarrierOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DoubleBarrierOption QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_QuantoDoubleBarrierOption(@_);
    bless $self, $pkg if defined($self);
}

*qvega = *QuantLibc::QuantoDoubleBarrierOption_qvega;
*qrho = *QuantLibc::QuantoDoubleBarrierOption_qrho;
*qlambda = *QuantLibc::QuantoDoubleBarrierOption_qlambda;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_QuantoDoubleBarrierOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticDoubleBarrierEngine ##############

package QuantLib::AnalyticDoubleBarrierEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticDoubleBarrierEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticDoubleBarrierEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::WulinYongDoubleBarrierEngine ##############

package QuantLib::WulinYongDoubleBarrierEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_WulinYongDoubleBarrierEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_WulinYongDoubleBarrierEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DeltaVolQuote ##############

package QuantLib::DeltaVolQuote;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::DeltaVolQuote___deref__;
*isNull = *QuantLibc::DeltaVolQuote_isNull;
*asObservable = *QuantLibc::DeltaVolQuote_asObservable;
*Spot = *QuantLibc::DeltaVolQuote_Spot;
*Spot = *QuantLibc::DeltaVolQuote_Spot;
*Fwd = *QuantLibc::DeltaVolQuote_Fwd;
*Fwd = *QuantLibc::DeltaVolQuote_Fwd;
*PaSpot = *QuantLibc::DeltaVolQuote_PaSpot;
*PaSpot = *QuantLibc::DeltaVolQuote_PaSpot;
*PaFwd = *QuantLibc::DeltaVolQuote_PaFwd;
*PaFwd = *QuantLibc::DeltaVolQuote_PaFwd;
*AtmNull = *QuantLibc::DeltaVolQuote_AtmNull;
*AtmNull = *QuantLibc::DeltaVolQuote_AtmNull;
*AtmSpot = *QuantLibc::DeltaVolQuote_AtmSpot;
*AtmSpot = *QuantLibc::DeltaVolQuote_AtmSpot;
*AtmFwd = *QuantLibc::DeltaVolQuote_AtmFwd;
*AtmFwd = *QuantLibc::DeltaVolQuote_AtmFwd;
*AtmDeltaNeutral = *QuantLibc::DeltaVolQuote_AtmDeltaNeutral;
*AtmDeltaNeutral = *QuantLibc::DeltaVolQuote_AtmDeltaNeutral;
*AtmVegaMax = *QuantLibc::DeltaVolQuote_AtmVegaMax;
*AtmVegaMax = *QuantLibc::DeltaVolQuote_AtmVegaMax;
*AtmGammaMax = *QuantLibc::DeltaVolQuote_AtmGammaMax;
*AtmGammaMax = *QuantLibc::DeltaVolQuote_AtmGammaMax;
*AtmPutCall50 = *QuantLibc::DeltaVolQuote_AtmPutCall50;
*AtmPutCall50 = *QuantLibc::DeltaVolQuote_AtmPutCall50;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DeltaVolQuote(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DeltaVolQuote($self);
        delete $OWNER{$self};
    }
}

*value = *QuantLibc::DeltaVolQuote_value;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DeltaVolQuoteHandle ##############

package QuantLib::DeltaVolQuoteHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DeltaVolQuoteHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::DeltaVolQuoteHandle___deref__;
*empty = *QuantLibc::DeltaVolQuoteHandle_empty;
*asObservable = *QuantLibc::DeltaVolQuoteHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DeltaVolQuoteHandle($self);
        delete $OWNER{$self};
    }
}

*value = *QuantLibc::DeltaVolQuoteHandle_value;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableDeltaVolQuoteHandle ##############

package QuantLib::RelinkableDeltaVolQuoteHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DeltaVolQuoteHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableDeltaVolQuoteHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableDeltaVolQuoteHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableDeltaVolQuoteHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::VannaVolgaDoubleBarrierEngine ##############

package QuantLib::VannaVolgaDoubleBarrierEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_VannaVolgaDoubleBarrierEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_VannaVolgaDoubleBarrierEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::VannaVolgaBarrierEngine ##############

package QuantLib::VannaVolgaBarrierEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_VannaVolgaBarrierEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_VannaVolgaBarrierEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticDoubleBarrierBinaryEngine ##############

package QuantLib::AnalyticDoubleBarrierBinaryEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticDoubleBarrierBinaryEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticDoubleBarrierBinaryEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BinomialDoubleBarrierEngine ##############

package QuantLib::BinomialDoubleBarrierEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BinomialDoubleBarrierEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BinomialDoubleBarrierEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PlainVanillaPayoff ##############

package QuantLib::PlainVanillaPayoff;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Payoff QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PlainVanillaPayoff(@_);
    bless $self, $pkg if defined($self);
}

*optionType = *QuantLibc::PlainVanillaPayoff_optionType;
*strike = *QuantLibc::PlainVanillaPayoff_strike;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PlainVanillaPayoff($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PercentageStrikePayoff ##############

package QuantLib::PercentageStrikePayoff;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Payoff QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PercentageStrikePayoff(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PercentageStrikePayoff($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CashOrNothingPayoff ##############

package QuantLib::CashOrNothingPayoff;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Payoff QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CashOrNothingPayoff(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CashOrNothingPayoff($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AssetOrNothingPayoff ##############

package QuantLib::AssetOrNothingPayoff;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Payoff QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AssetOrNothingPayoff(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AssetOrNothingPayoff($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SuperSharePayoff ##############

package QuantLib::SuperSharePayoff;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Payoff QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SuperSharePayoff(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SuperSharePayoff($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GapPayoff ##############

package QuantLib::GapPayoff;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Payoff QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GapPayoff(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GapPayoff($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BasketPayoff ##############

package QuantLib::BasketPayoff;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Payoff QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BasketPayoff(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BasketPayoff($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MinBasketPayoff ##############

package QuantLib::MinBasketPayoff;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::BasketPayoff QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MinBasketPayoff(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MinBasketPayoff($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MaxBasketPayoff ##############

package QuantLib::MaxBasketPayoff;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::BasketPayoff QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MaxBasketPayoff(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MaxBasketPayoff($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AverageBasketPayoff ##############

package QuantLib::AverageBasketPayoff;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::BasketPayoff QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AverageBasketPayoff(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AverageBasketPayoff($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BasketOption ##############

package QuantLib::BasketOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::MultiAssetOption QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BasketOption(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BasketOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MCEuropeanBasketEngine ##############

package QuantLib::MCEuropeanBasketEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MCEuropeanBasketEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MCEuropeanBasketEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MCAmericanBasketEngine ##############

package QuantLib::MCAmericanBasketEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MCAmericanBasketEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MCAmericanBasketEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::StulzEngine ##############

package QuantLib::StulzEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_StulzEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_StulzEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EverestOption ##############

package QuantLib::EverestOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::MultiAssetOption QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EverestOption(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EverestOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MCEverestEngine ##############

package QuantLib::MCEverestEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MCEverestEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MCEverestEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HimalayaOption ##############

package QuantLib::HimalayaOption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::MultiAssetOption QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HimalayaOption(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HimalayaOption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MCHimalayaEngine ##############

package QuantLib::MCHimalayaEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MCHimalayaEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MCHimalayaEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackDeltaCalculator ##############

package QuantLib::BlackDeltaCalculator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackDeltaCalculator(@_);
    bless $self, $pkg if defined($self);
}

*deltaFromStrike = *QuantLibc::BlackDeltaCalculator_deltaFromStrike;
*strikeFromDelta = *QuantLibc::BlackDeltaCalculator_strikeFromDelta;
*atmStrike = *QuantLibc::BlackDeltaCalculator_atmStrike;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackDeltaCalculator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CallabilityPrice ##############

package QuantLib::CallabilityPrice;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Dirty = *QuantLibc::CallabilityPrice_Dirty;
*Clean = *QuantLibc::CallabilityPrice_Clean;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CallabilityPrice(@_);
    bless $self, $pkg if defined($self);
}

*amount = *QuantLibc::CallabilityPrice_amount;
*type = *QuantLibc::CallabilityPrice_type;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CallabilityPrice($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Callability ##############

package QuantLib::Callability;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::Callability___deref__;
*isNull = *QuantLibc::Callability_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Callability(@_);
    bless $self, $pkg if defined($self);
}

*Call = *QuantLibc::Callability_Call;
*Call = *QuantLibc::Callability_Call;
*Put = *QuantLibc::Callability_Put;
*Put = *QuantLibc::Callability_Put;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Callability($self);
        delete $OWNER{$self};
    }
}

*price = *QuantLibc::Callability_price;
*type = *QuantLibc::Callability_type;
*date = *QuantLibc::Callability_date;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SoftCallability ##############

package QuantLib::SoftCallability;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Callability QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SoftCallability(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SoftCallability($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CallabilitySchedule ##############

package QuantLib::CallabilitySchedule;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CallabilitySchedule(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::CallabilitySchedule_size;
*empty = *QuantLibc::CallabilitySchedule_empty;
*clear = *QuantLibc::CallabilitySchedule_clear;
*push = *QuantLibc::CallabilitySchedule_push;
*pop = *QuantLibc::CallabilitySchedule_pop;
*get = *QuantLibc::CallabilitySchedule_get;
*set = *QuantLibc::CallabilitySchedule_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CallabilitySchedule($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Seasonality ##############

package QuantLib::Seasonality;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::Seasonality___deref__;
*isNull = *QuantLibc::Seasonality_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Seasonality(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Seasonality($self);
        delete $OWNER{$self};
    }
}

*correctZeroRate = *QuantLibc::Seasonality_correctZeroRate;
*correctYoYRate = *QuantLibc::Seasonality_correctYoYRate;
*isConsistent = *QuantLibc::Seasonality_isConsistent;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MultiplicativePriceSeasonalityPtr ##############

package QuantLib::MultiplicativePriceSeasonalityPtr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Seasonality QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MultiplicativePriceSeasonalityPtr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MultiplicativePriceSeasonalityPtr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YoYInflationTermStructure ##############

package QuantLib::YoYInflationTermStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::YoYInflationTermStructure___deref__;
*isNull = *QuantLibc::YoYInflationTermStructure_isNull;
*asObservable = *QuantLibc::YoYInflationTermStructure_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YoYInflationTermStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YoYInflationTermStructure($self);
        delete $OWNER{$self};
    }
}

*yoyRate = *QuantLibc::YoYInflationTermStructure_yoyRate;
*dayCounter = *QuantLibc::YoYInflationTermStructure_dayCounter;
*calendar = *QuantLibc::YoYInflationTermStructure_calendar;
*referenceDate = *QuantLibc::YoYInflationTermStructure_referenceDate;
*maxDate = *QuantLibc::YoYInflationTermStructure_maxDate;
*maxTime = *QuantLibc::YoYInflationTermStructure_maxTime;
*observationLag = *QuantLibc::YoYInflationTermStructure_observationLag;
*frequency = *QuantLibc::YoYInflationTermStructure_frequency;
*indexIsInterpolated = *QuantLibc::YoYInflationTermStructure_indexIsInterpolated;
*baseRate = *QuantLibc::YoYInflationTermStructure_baseRate;
*nominalTermStructure = *QuantLibc::YoYInflationTermStructure_nominalTermStructure;
*baseDate = *QuantLibc::YoYInflationTermStructure_baseDate;
*setSeasonality = *QuantLibc::YoYInflationTermStructure_setSeasonality;
*seasonality = *QuantLibc::YoYInflationTermStructure_seasonality;
*hasSeasonality = *QuantLibc::YoYInflationTermStructure_hasSeasonality;
*enableExtrapolation = *QuantLibc::YoYInflationTermStructure_enableExtrapolation;
*disableExtrapolation = *QuantLibc::YoYInflationTermStructure_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::YoYInflationTermStructure_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YoYInflationTermStructureHandle ##############

package QuantLib::YoYInflationTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YoYInflationTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::YoYInflationTermStructureHandle___deref__;
*empty = *QuantLibc::YoYInflationTermStructureHandle_empty;
*asObservable = *QuantLibc::YoYInflationTermStructureHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YoYInflationTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

*yoyRate = *QuantLibc::YoYInflationTermStructureHandle_yoyRate;
*dayCounter = *QuantLibc::YoYInflationTermStructureHandle_dayCounter;
*calendar = *QuantLibc::YoYInflationTermStructureHandle_calendar;
*referenceDate = *QuantLibc::YoYInflationTermStructureHandle_referenceDate;
*maxDate = *QuantLibc::YoYInflationTermStructureHandle_maxDate;
*maxTime = *QuantLibc::YoYInflationTermStructureHandle_maxTime;
*observationLag = *QuantLibc::YoYInflationTermStructureHandle_observationLag;
*frequency = *QuantLibc::YoYInflationTermStructureHandle_frequency;
*indexIsInterpolated = *QuantLibc::YoYInflationTermStructureHandle_indexIsInterpolated;
*baseRate = *QuantLibc::YoYInflationTermStructureHandle_baseRate;
*nominalTermStructure = *QuantLibc::YoYInflationTermStructureHandle_nominalTermStructure;
*baseDate = *QuantLibc::YoYInflationTermStructureHandle_baseDate;
*setSeasonality = *QuantLibc::YoYInflationTermStructureHandle_setSeasonality;
*seasonality = *QuantLibc::YoYInflationTermStructureHandle_seasonality;
*hasSeasonality = *QuantLibc::YoYInflationTermStructureHandle_hasSeasonality;
*enableExtrapolation = *QuantLibc::YoYInflationTermStructureHandle_enableExtrapolation;
*disableExtrapolation = *QuantLibc::YoYInflationTermStructureHandle_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::YoYInflationTermStructureHandle_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableYoYInflationTermStructureHandle ##############

package QuantLib::RelinkableYoYInflationTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYInflationTermStructureHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableYoYInflationTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableYoYInflationTermStructureHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableYoYInflationTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZeroInflationTermStructure ##############

package QuantLib::ZeroInflationTermStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::ZeroInflationTermStructure___deref__;
*isNull = *QuantLibc::ZeroInflationTermStructure_isNull;
*asObservable = *QuantLibc::ZeroInflationTermStructure_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZeroInflationTermStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZeroInflationTermStructure($self);
        delete $OWNER{$self};
    }
}

*zeroRate = *QuantLibc::ZeroInflationTermStructure_zeroRate;
*dayCounter = *QuantLibc::ZeroInflationTermStructure_dayCounter;
*calendar = *QuantLibc::ZeroInflationTermStructure_calendar;
*referenceDate = *QuantLibc::ZeroInflationTermStructure_referenceDate;
*maxDate = *QuantLibc::ZeroInflationTermStructure_maxDate;
*maxTime = *QuantLibc::ZeroInflationTermStructure_maxTime;
*observationLag = *QuantLibc::ZeroInflationTermStructure_observationLag;
*frequency = *QuantLibc::ZeroInflationTermStructure_frequency;
*indexIsInterpolated = *QuantLibc::ZeroInflationTermStructure_indexIsInterpolated;
*baseRate = *QuantLibc::ZeroInflationTermStructure_baseRate;
*nominalTermStructure = *QuantLibc::ZeroInflationTermStructure_nominalTermStructure;
*baseDate = *QuantLibc::ZeroInflationTermStructure_baseDate;
*setSeasonality = *QuantLibc::ZeroInflationTermStructure_setSeasonality;
*seasonality = *QuantLibc::ZeroInflationTermStructure_seasonality;
*hasSeasonality = *QuantLibc::ZeroInflationTermStructure_hasSeasonality;
*enableExtrapolation = *QuantLibc::ZeroInflationTermStructure_enableExtrapolation;
*disableExtrapolation = *QuantLibc::ZeroInflationTermStructure_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::ZeroInflationTermStructure_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZeroInflationTermStructureHandle ##############

package QuantLib::ZeroInflationTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZeroInflationTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::ZeroInflationTermStructureHandle___deref__;
*empty = *QuantLibc::ZeroInflationTermStructureHandle_empty;
*asObservable = *QuantLibc::ZeroInflationTermStructureHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZeroInflationTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

*zeroRate = *QuantLibc::ZeroInflationTermStructureHandle_zeroRate;
*dayCounter = *QuantLibc::ZeroInflationTermStructureHandle_dayCounter;
*calendar = *QuantLibc::ZeroInflationTermStructureHandle_calendar;
*referenceDate = *QuantLibc::ZeroInflationTermStructureHandle_referenceDate;
*maxDate = *QuantLibc::ZeroInflationTermStructureHandle_maxDate;
*maxTime = *QuantLibc::ZeroInflationTermStructureHandle_maxTime;
*observationLag = *QuantLibc::ZeroInflationTermStructureHandle_observationLag;
*frequency = *QuantLibc::ZeroInflationTermStructureHandle_frequency;
*indexIsInterpolated = *QuantLibc::ZeroInflationTermStructureHandle_indexIsInterpolated;
*baseRate = *QuantLibc::ZeroInflationTermStructureHandle_baseRate;
*nominalTermStructure = *QuantLibc::ZeroInflationTermStructureHandle_nominalTermStructure;
*baseDate = *QuantLibc::ZeroInflationTermStructureHandle_baseDate;
*setSeasonality = *QuantLibc::ZeroInflationTermStructureHandle_setSeasonality;
*seasonality = *QuantLibc::ZeroInflationTermStructureHandle_seasonality;
*hasSeasonality = *QuantLibc::ZeroInflationTermStructureHandle_hasSeasonality;
*enableExtrapolation = *QuantLibc::ZeroInflationTermStructureHandle_enableExtrapolation;
*disableExtrapolation = *QuantLibc::ZeroInflationTermStructureHandle_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::ZeroInflationTermStructureHandle_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableZeroInflationTermStructureHandle ##############

package QuantLib::RelinkableZeroInflationTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ZeroInflationTermStructureHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableZeroInflationTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableZeroInflationTermStructureHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableZeroInflationTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Region ##############

package QuantLib::Region;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*name = *QuantLibc::Region_name;
*code = *QuantLibc::Region_code;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Region($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CustomRegion ##############

package QuantLib::CustomRegion;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Region QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CustomRegion(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CustomRegion($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InflationIndex ##############

package QuantLib::InflationIndex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Index QuantLib );
%OWNER = ();
%ITERATORS = ();
*interpolated = *QuantLibc::InflationIndex_interpolated;
*frequency = *QuantLibc::InflationIndex_frequency;
*availabilityLag = *QuantLibc::InflationIndex_availabilityLag;
*currency = *QuantLibc::InflationIndex_currency;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InflationIndex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZeroInflationIndex ##############

package QuantLib::ZeroInflationIndex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::InflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZeroInflationIndex(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZeroInflationIndex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YoYInflationIndex ##############

package QuantLib::YoYInflationIndex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::InflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YoYInflationIndex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EUHICP ##############

package QuantLib::EUHICP;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ZeroInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EUHICP(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EUHICP($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::EUHICPXT ##############

package QuantLib::EUHICPXT;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ZeroInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_EUHICPXT(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_EUHICPXT($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FRHICP ##############

package QuantLib::FRHICP;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ZeroInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FRHICP(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FRHICP($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::UKRPI ##############

package QuantLib::UKRPI;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ZeroInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_UKRPI(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_UKRPI($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::USCPI ##############

package QuantLib::USCPI;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ZeroInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_USCPI(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_USCPI($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZACPI ##############

package QuantLib::ZACPI;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ZeroInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZACPI(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZACPI($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YYEUHICP ##############

package QuantLib::YYEUHICP;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YYEUHICP(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YYEUHICP($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YYEUHICPXT ##############

package QuantLib::YYEUHICPXT;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YYEUHICPXT(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YYEUHICPXT($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YYFRHICP ##############

package QuantLib::YYFRHICP;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YYFRHICP(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YYFRHICP($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YYUKRPI ##############

package QuantLib::YYUKRPI;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YYUKRPI(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YYUKRPI($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YYUSCPI ##############

package QuantLib::YYUSCPI;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YYUSCPI(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YYUSCPI($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YYZACPI ##############

package QuantLib::YYZACPI;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYInflationIndex QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YYZACPI(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YYZACPI($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CPI ##############

package QuantLib::CPI;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*AsIndex = *QuantLibc::CPI_AsIndex;
*Flat = *QuantLibc::CPI_Flat;
*Linear = *QuantLibc::CPI_Linear;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CPI(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CPI($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZeroHelper ##############

package QuantLib::ZeroHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::ZeroHelper___deref__;
*isNull = *QuantLibc::ZeroHelper_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZeroHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZeroHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YoYHelper ##############

package QuantLib::YoYHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::YoYHelper___deref__;
*isNull = *QuantLibc::YoYHelper_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YoYHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YoYHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZeroHelperVector ##############

package QuantLib::ZeroHelperVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZeroHelperVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::ZeroHelperVector_size;
*empty = *QuantLibc::ZeroHelperVector_empty;
*clear = *QuantLibc::ZeroHelperVector_clear;
*push = *QuantLibc::ZeroHelperVector_push;
*pop = *QuantLibc::ZeroHelperVector_pop;
*get = *QuantLibc::ZeroHelperVector_get;
*set = *QuantLibc::ZeroHelperVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZeroHelperVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YoYHelperVector ##############

package QuantLib::YoYHelperVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YoYHelperVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::YoYHelperVector_size;
*empty = *QuantLibc::YoYHelperVector_empty;
*clear = *QuantLibc::YoYHelperVector_clear;
*push = *QuantLibc::YoYHelperVector_push;
*pop = *QuantLibc::YoYHelperVector_pop;
*get = *QuantLibc::YoYHelperVector_get;
*set = *QuantLibc::YoYHelperVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YoYHelperVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZeroCouponInflationSwapHelper ##############

package QuantLib::ZeroCouponInflationSwapHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ZeroHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZeroCouponInflationSwapHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZeroCouponInflationSwapHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YearOnYearInflationSwapHelper ##############

package QuantLib::YearOnYearInflationSwapHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YearOnYearInflationSwapHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YearOnYearInflationSwapHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PiecewiseZeroInflation ##############

package QuantLib::PiecewiseZeroInflation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ZeroInflationTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PiecewiseZeroInflation(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::PiecewiseZeroInflation_dates;
*times = *QuantLibc::PiecewiseZeroInflation_times;
*nodes = *QuantLibc::PiecewiseZeroInflation_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PiecewiseZeroInflation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PiecewiseYoYInflation ##############

package QuantLib::PiecewiseYoYInflation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYInflationTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PiecewiseYoYInflation(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::PiecewiseYoYInflation_dates;
*times = *QuantLibc::PiecewiseYoYInflation_times;
*nodes = *QuantLibc::PiecewiseYoYInflation_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PiecewiseYoYInflation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZeroCouponInflationSwap ##############

package QuantLib::ZeroCouponInflationSwap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
*Receiver = *QuantLibc::ZeroCouponInflationSwap_Receiver;
*Receiver = *QuantLibc::ZeroCouponInflationSwap_Receiver;
*Payer = *QuantLibc::ZeroCouponInflationSwap_Payer;
*Payer = *QuantLibc::ZeroCouponInflationSwap_Payer;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZeroCouponInflationSwap(@_);
    bless $self, $pkg if defined($self);
}

*fairRate = *QuantLibc::ZeroCouponInflationSwap_fairRate;
*fixedLegNPV = *QuantLibc::ZeroCouponInflationSwap_fixedLegNPV;
*inflationLegNPV = *QuantLibc::ZeroCouponInflationSwap_inflationLegNPV;
*fixedLeg = *QuantLibc::ZeroCouponInflationSwap_fixedLeg;
*inflationLeg = *QuantLibc::ZeroCouponInflationSwap_inflationLeg;
*type = *QuantLibc::ZeroCouponInflationSwap_type;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZeroCouponInflationSwap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YearOnYearInflationSwap ##############

package QuantLib::YearOnYearInflationSwap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
*Receiver = *QuantLibc::YearOnYearInflationSwap_Receiver;
*Receiver = *QuantLibc::YearOnYearInflationSwap_Receiver;
*Payer = *QuantLibc::YearOnYearInflationSwap_Payer;
*Payer = *QuantLibc::YearOnYearInflationSwap_Payer;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YearOnYearInflationSwap(@_);
    bless $self, $pkg if defined($self);
}

*fairRate = *QuantLibc::YearOnYearInflationSwap_fairRate;
*fixedLegNPV = *QuantLibc::YearOnYearInflationSwap_fixedLegNPV;
*yoyLegNPV = *QuantLibc::YearOnYearInflationSwap_yoyLegNPV;
*fairSpread = *QuantLibc::YearOnYearInflationSwap_fairSpread;
*fixedLeg = *QuantLibc::YearOnYearInflationSwap_fixedLeg;
*yoyLeg = *QuantLibc::YearOnYearInflationSwap_yoyLeg;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YearOnYearInflationSwap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CPISwap ##############

package QuantLib::CPISwap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
*Receiver = *QuantLibc::CPISwap_Receiver;
*Receiver = *QuantLibc::CPISwap_Receiver;
*Payer = *QuantLibc::CPISwap_Payer;
*Payer = *QuantLibc::CPISwap_Payer;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CPISwap(@_);
    bless $self, $pkg if defined($self);
}

*fairRate = *QuantLibc::CPISwap_fairRate;
*floatLegNPV = *QuantLibc::CPISwap_floatLegNPV;
*fairSpread = *QuantLibc::CPISwap_fairSpread;
*fixedLegNPV = *QuantLibc::CPISwap_fixedLegNPV;
*cpiLeg = *QuantLibc::CPISwap_cpiLeg;
*floatLeg = *QuantLibc::CPISwap_floatLeg;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CPISwap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YoYInflationCapFloor ##############

package QuantLib::YoYInflationCapFloor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
*impliedVolatility = *QuantLibc::YoYInflationCapFloor_impliedVolatility;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YoYInflationCapFloor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YoYInflationCapFloor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YoYInflationCap ##############

package QuantLib::YoYInflationCap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYInflationCapFloor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YoYInflationCap(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YoYInflationCap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YoYInflationFloor ##############

package QuantLib::YoYInflationFloor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYInflationCapFloor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YoYInflationFloor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YoYInflationFloor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::YoYInflationCollar ##############

package QuantLib::YoYInflationCollar;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YoYInflationCapFloor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_YoYInflationCollar(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_YoYInflationCollar($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ShortRateModel ##############

package QuantLib::ShortRateModel;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::ShortRateModel___deref__;
*isNull = *QuantLibc::ShortRateModel_isNull;
*asObservable = *QuantLibc::ShortRateModel_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ShortRateModel(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ShortRateModel($self);
        delete $OWNER{$self};
    }
}

*params = *QuantLibc::ShortRateModel_params;
*calibrate = *QuantLibc::ShortRateModel_calibrate;
*value = *QuantLibc::ShortRateModel_value;
*endCriteria = *QuantLibc::ShortRateModel_endCriteria;
*setParams = *QuantLibc::ShortRateModel_setParams;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ShortRateModelHandle ##############

package QuantLib::ShortRateModelHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ShortRateModelHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::ShortRateModelHandle___deref__;
*empty = *QuantLibc::ShortRateModelHandle_empty;
*asObservable = *QuantLibc::ShortRateModelHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ShortRateModelHandle($self);
        delete $OWNER{$self};
    }
}

*params = *QuantLibc::ShortRateModelHandle_params;
*calibrate = *QuantLibc::ShortRateModelHandle_calibrate;
*value = *QuantLibc::ShortRateModelHandle_value;
*endCriteria = *QuantLibc::ShortRateModelHandle_endCriteria;
*setParams = *QuantLibc::ShortRateModelHandle_setParams;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableShortRateModelHandle ##############

package QuantLib::RelinkableShortRateModelHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ShortRateModelHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableShortRateModelHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableShortRateModelHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableShortRateModelHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Vasicek ##############

package QuantLib::Vasicek;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ShortRateModel QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Vasicek(@_);
    bless $self, $pkg if defined($self);
}

*discount = *QuantLibc::Vasicek_discount;
*discountBond = *QuantLibc::Vasicek_discountBond;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Vasicek($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HullWhite ##############

package QuantLib::HullWhite;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ShortRateModel QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HullWhite(@_);
    bless $self, $pkg if defined($self);
}

*discount = *QuantLibc::HullWhite_discount;
*discountBond = *QuantLibc::HullWhite_discountBond;
*convexityBias = *QuantLibc::HullWhite_convexityBias;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HullWhite($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackKarasinski ##############

package QuantLib::BlackKarasinski;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ShortRateModel QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackKarasinski(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackKarasinski($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::G2 ##############

package QuantLib::G2;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::ShortRateModel QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_G2(@_);
    bless $self, $pkg if defined($self);
}

*discount = *QuantLibc::G2_discount;
*discountBond = *QuantLibc::G2_discountBond;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_G2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::JamshidianSwaptionEngine ##############

package QuantLib::JamshidianSwaptionEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_JamshidianSwaptionEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_JamshidianSwaptionEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TreeSwaptionEngine ##############

package QuantLib::TreeSwaptionEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TreeSwaptionEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TreeSwaptionEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AnalyticCapFloorEngine ##############

package QuantLib::AnalyticCapFloorEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AnalyticCapFloorEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AnalyticCapFloorEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TreeCapFloorEngine ##############

package QuantLib::TreeCapFloorEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TreeCapFloorEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TreeCapFloorEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::G2SwaptionEngine ##############

package QuantLib::G2SwaptionEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_G2SwaptionEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_G2SwaptionEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FdG2SwaptionEngine ##############

package QuantLib::FdG2SwaptionEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FdG2SwaptionEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FdG2SwaptionEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FdHullWhiteSwaptionEngine ##############

package QuantLib::FdHullWhiteSwaptionEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FdHullWhiteSwaptionEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FdHullWhiteSwaptionEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Bond ##############

package QuantLib::Bond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Bond(@_);
    bless $self, $pkg if defined($self);
}

*nextCouponRate = *QuantLibc::Bond_nextCouponRate;
*previousCouponRate = *QuantLibc::Bond_previousCouponRate;
*settlementDays = *QuantLibc::Bond_settlementDays;
*settlementDate = *QuantLibc::Bond_settlementDate;
*startDate = *QuantLibc::Bond_startDate;
*maturityDate = *QuantLibc::Bond_maturityDate;
*issueDate = *QuantLibc::Bond_issueDate;
*cashflows = *QuantLibc::Bond_cashflows;
*redemptions = *QuantLibc::Bond_redemptions;
*redemption = *QuantLibc::Bond_redemption;
*calendar = *QuantLibc::Bond_calendar;
*notionals = *QuantLibc::Bond_notionals;
*notional = *QuantLibc::Bond_notional;
*cleanPrice = *QuantLibc::Bond_cleanPrice;
*dirtyPrice = *QuantLibc::Bond_dirtyPrice;
*yield = *QuantLibc::Bond_yield;
*accruedAmount = *QuantLibc::Bond_accruedAmount;
*settlementValue = *QuantLibc::Bond_settlementValue;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Bond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZeroCouponBond ##############

package QuantLib::ZeroCouponBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bond QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZeroCouponBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZeroCouponBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FixedRateBond ##############

package QuantLib::FixedRateBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bond QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FixedRateBond(@_);
    bless $self, $pkg if defined($self);
}

*frequency = *QuantLibc::FixedRateBond_frequency;
*dayCounter = *QuantLibc::FixedRateBond_dayCounter;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FixedRateBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AmortizingFixedRateBond ##############

package QuantLib::AmortizingFixedRateBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bond QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AmortizingFixedRateBond(@_);
    bless $self, $pkg if defined($self);
}

*frequency = *QuantLibc::AmortizingFixedRateBond_frequency;
*dayCounter = *QuantLibc::AmortizingFixedRateBond_dayCounter;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AmortizingFixedRateBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AmortizingFloatingRateBond ##############

package QuantLib::AmortizingFloatingRateBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bond QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AmortizingFloatingRateBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AmortizingFloatingRateBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FloatingRateBond ##############

package QuantLib::FloatingRateBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bond QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FloatingRateBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FloatingRateBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CmsRateBond ##############

package QuantLib::CmsRateBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bond QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CmsRateBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CmsRateBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DiscountingBondEngine ##############

package QuantLib::DiscountingBondEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DiscountingBondEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DiscountingBondEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CallableFixedRateBond ##############

package QuantLib::CallableFixedRateBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bond QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CallableFixedRateBond(@_);
    bless $self, $pkg if defined($self);
}

*OAS = *QuantLibc::CallableFixedRateBond_OAS;
*cleanPriceOAS = *QuantLibc::CallableFixedRateBond_cleanPriceOAS;
*effectiveDuration = *QuantLibc::CallableFixedRateBond_effectiveDuration;
*effectiveConvexity = *QuantLibc::CallableFixedRateBond_effectiveConvexity;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CallableFixedRateBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TreeCallableFixedRateBondEngine ##############

package QuantLib::TreeCallableFixedRateBondEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TreeCallableFixedRateBondEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TreeCallableFixedRateBondEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackCallableFixedRateBondEngine ##############

package QuantLib::BlackCallableFixedRateBondEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackCallableFixedRateBondEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackCallableFixedRateBondEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CPIBond ##############

package QuantLib::CPIBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bond QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CPIBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CPIBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BondFunctions ##############

package QuantLib::BondFunctions;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*startDate = *QuantLibc::BondFunctions_startDate;
*maturityDate = *QuantLibc::BondFunctions_maturityDate;
*isTradable = *QuantLibc::BondFunctions_isTradable;
*previousCashFlowDate = *QuantLibc::BondFunctions_previousCashFlowDate;
*nextCashFlowDate = *QuantLibc::BondFunctions_nextCashFlowDate;
*previousCashFlowAmount = *QuantLibc::BondFunctions_previousCashFlowAmount;
*nextCashFlowAmount = *QuantLibc::BondFunctions_nextCashFlowAmount;
*previousCouponRate = *QuantLibc::BondFunctions_previousCouponRate;
*nextCouponRate = *QuantLibc::BondFunctions_nextCouponRate;
*accrualStartDate = *QuantLibc::BondFunctions_accrualStartDate;
*accrualEndDate = *QuantLibc::BondFunctions_accrualEndDate;
*accrualPeriod = *QuantLibc::BondFunctions_accrualPeriod;
*accrualDays = *QuantLibc::BondFunctions_accrualDays;
*accruedPeriod = *QuantLibc::BondFunctions_accruedPeriod;
*accruedDays = *QuantLibc::BondFunctions_accruedDays;
*accruedAmount = *QuantLibc::BondFunctions_accruedAmount;
*atmRate = *QuantLibc::BondFunctions_atmRate;
*cleanPrice = *QuantLibc::BondFunctions_cleanPrice;
*bps = *QuantLibc::BondFunctions_bps;
*yield = *QuantLibc::BondFunctions_yield;
*yieldBrent = *QuantLibc::BondFunctions_yieldBrent;
*yieldBisection = *QuantLibc::BondFunctions_yieldBisection;
*yieldFalsePosition = *QuantLibc::BondFunctions_yieldFalsePosition;
*yieldRidder = *QuantLibc::BondFunctions_yieldRidder;
*yieldSecant = *QuantLibc::BondFunctions_yieldSecant;
*duration = *QuantLibc::BondFunctions_duration;
*convexity = *QuantLibc::BondFunctions_convexity;
*basisPointValue = *QuantLibc::BondFunctions_basisPointValue;
*yieldValueBasisPoint = *QuantLibc::BondFunctions_yieldValueBasisPoint;
*zSpread = *QuantLibc::BondFunctions_zSpread;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BondFunctions(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BondFunctions($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CapFloor ##############

package QuantLib::CapFloor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
*impliedVolatility = *QuantLibc::CapFloor_impliedVolatility;
*floatingLeg = *QuantLibc::CapFloor_floatingLeg;
*capRates = *QuantLibc::CapFloor_capRates;
*floorRates = *QuantLibc::CapFloor_floorRates;
*startDate = *QuantLibc::CapFloor_startDate;
*maturityDate = *QuantLibc::CapFloor_maturityDate;
*atmRate = *QuantLibc::CapFloor_atmRate;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CapFloor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CapFloor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Cap ##############

package QuantLib::Cap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CapFloor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Cap(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Cap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Floor ##############

package QuantLib::Floor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CapFloor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Floor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Floor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Collar ##############

package QuantLib::Collar;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CapFloor QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Collar(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Collar($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackCapFloorEngine ##############

package QuantLib::BlackCapFloorEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackCapFloorEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackCapFloorEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BachelierCapFloorEngine ##############

package QuantLib::BachelierCapFloorEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BachelierCapFloorEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BachelierCapFloorEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Dividend ##############

package QuantLib::Dividend;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::Dividend___deref__;
*isNull = *QuantLibc::Dividend_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Dividend(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Dividend($self);
        delete $OWNER{$self};
    }
}

*amount = *QuantLibc::Dividend_amount;
*date = *QuantLibc::Dividend_date;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FixedDividend ##############

package QuantLib::FixedDividend;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Dividend QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FixedDividend(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FixedDividend($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FractionalDividend ##############

package QuantLib::FractionalDividend;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Dividend QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FractionalDividend(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FractionalDividend($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DividendSchedule ##############

package QuantLib::DividendSchedule;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DividendSchedule(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::DividendSchedule_size;
*empty = *QuantLibc::DividendSchedule_empty;
*clear = *QuantLibc::DividendSchedule_clear;
*push = *QuantLibc::DividendSchedule_push;
*pop = *QuantLibc::DividendSchedule_pop;
*get = *QuantLibc::DividendSchedule_get;
*set = *QuantLibc::DividendSchedule_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DividendSchedule($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ConvertibleZeroCouponBond ##############

package QuantLib::ConvertibleZeroCouponBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bond QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ConvertibleZeroCouponBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ConvertibleZeroCouponBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ConvertibleFixedCouponBond ##############

package QuantLib::ConvertibleFixedCouponBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bond QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ConvertibleFixedCouponBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ConvertibleFixedCouponBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ConvertibleFloatingRateBond ##############

package QuantLib::ConvertibleFloatingRateBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Bond QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ConvertibleFloatingRateBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ConvertibleFloatingRateBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BinomialConvertibleEngine ##############

package QuantLib::BinomialConvertibleEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BinomialConvertibleEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BinomialConvertibleEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DefaultProbabilityTermStructure ##############

package QuantLib::DefaultProbabilityTermStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::DefaultProbabilityTermStructure___deref__;
*isNull = *QuantLibc::DefaultProbabilityTermStructure_isNull;
*asObservable = *QuantLibc::DefaultProbabilityTermStructure_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DefaultProbabilityTermStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DefaultProbabilityTermStructure($self);
        delete $OWNER{$self};
    }
}

*dayCounter = *QuantLibc::DefaultProbabilityTermStructure_dayCounter;
*calendar = *QuantLibc::DefaultProbabilityTermStructure_calendar;
*referenceDate = *QuantLibc::DefaultProbabilityTermStructure_referenceDate;
*maxDate = *QuantLibc::DefaultProbabilityTermStructure_maxDate;
*maxTime = *QuantLibc::DefaultProbabilityTermStructure_maxTime;
*defaultProbability = *QuantLibc::DefaultProbabilityTermStructure_defaultProbability;
*survivalProbability = *QuantLibc::DefaultProbabilityTermStructure_survivalProbability;
*defaultDensity = *QuantLibc::DefaultProbabilityTermStructure_defaultDensity;
*hazardRate = *QuantLibc::DefaultProbabilityTermStructure_hazardRate;
*enableExtrapolation = *QuantLibc::DefaultProbabilityTermStructure_enableExtrapolation;
*disableExtrapolation = *QuantLibc::DefaultProbabilityTermStructure_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::DefaultProbabilityTermStructure_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DefaultProbabilityTermStructureHandle ##############

package QuantLib::DefaultProbabilityTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DefaultProbabilityTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::DefaultProbabilityTermStructureHandle___deref__;
*empty = *QuantLibc::DefaultProbabilityTermStructureHandle_empty;
*asObservable = *QuantLibc::DefaultProbabilityTermStructureHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DefaultProbabilityTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

*dayCounter = *QuantLibc::DefaultProbabilityTermStructureHandle_dayCounter;
*calendar = *QuantLibc::DefaultProbabilityTermStructureHandle_calendar;
*referenceDate = *QuantLibc::DefaultProbabilityTermStructureHandle_referenceDate;
*maxDate = *QuantLibc::DefaultProbabilityTermStructureHandle_maxDate;
*maxTime = *QuantLibc::DefaultProbabilityTermStructureHandle_maxTime;
*defaultProbability = *QuantLibc::DefaultProbabilityTermStructureHandle_defaultProbability;
*survivalProbability = *QuantLibc::DefaultProbabilityTermStructureHandle_survivalProbability;
*defaultDensity = *QuantLibc::DefaultProbabilityTermStructureHandle_defaultDensity;
*hazardRate = *QuantLibc::DefaultProbabilityTermStructureHandle_hazardRate;
*enableExtrapolation = *QuantLibc::DefaultProbabilityTermStructureHandle_enableExtrapolation;
*disableExtrapolation = *QuantLibc::DefaultProbabilityTermStructureHandle_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::DefaultProbabilityTermStructureHandle_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableDefaultProbabilityTermStructureHandle ##############

package QuantLib::RelinkableDefaultProbabilityTermStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DefaultProbabilityTermStructureHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableDefaultProbabilityTermStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableDefaultProbabilityTermStructureHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableDefaultProbabilityTermStructureHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FlatHazardRate ##############

package QuantLib::FlatHazardRate;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DefaultProbabilityTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FlatHazardRate(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FlatHazardRate($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HazardRateCurve ##############

package QuantLib::HazardRateCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DefaultProbabilityTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HazardRateCurve(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::HazardRateCurve_dates;
*hazardRates = *QuantLibc::HazardRateCurve_hazardRates;
*nodes = *QuantLibc::HazardRateCurve_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HazardRateCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DefaultDensityCurve ##############

package QuantLib::DefaultDensityCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DefaultProbabilityTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DefaultDensityCurve(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::DefaultDensityCurve_dates;
*defaultDensities = *QuantLibc::DefaultDensityCurve_defaultDensities;
*nodes = *QuantLibc::DefaultDensityCurve_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DefaultDensityCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DefaultProbabilityHelper ##############

package QuantLib::DefaultProbabilityHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::DefaultProbabilityHelper___deref__;
*isNull = *QuantLibc::DefaultProbabilityHelper_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DefaultProbabilityHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DefaultProbabilityHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DefaultProbabilityHelperVector ##############

package QuantLib::DefaultProbabilityHelperVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DefaultProbabilityHelperVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::DefaultProbabilityHelperVector_size;
*empty = *QuantLibc::DefaultProbabilityHelperVector_empty;
*clear = *QuantLibc::DefaultProbabilityHelperVector_clear;
*push = *QuantLibc::DefaultProbabilityHelperVector_push;
*pop = *QuantLibc::DefaultProbabilityHelperVector_pop;
*get = *QuantLibc::DefaultProbabilityHelperVector_get;
*set = *QuantLibc::DefaultProbabilityHelperVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DefaultProbabilityHelperVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SpreadCdsHelper ##############

package QuantLib::SpreadCdsHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DefaultProbabilityHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SpreadCdsHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SpreadCdsHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::UpfrontCdsHelper ##############

package QuantLib::UpfrontCdsHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DefaultProbabilityHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_UpfrontCdsHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_UpfrontCdsHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HazardRate ##############

package QuantLib::HazardRate;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HazardRate(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HazardRate($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DefaultDensity ##############

package QuantLib::DefaultDensity;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DefaultDensity(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DefaultDensity($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PiecewiseFlatHazardRate ##############

package QuantLib::PiecewiseFlatHazardRate;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::DefaultProbabilityTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PiecewiseFlatHazardRate(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::PiecewiseFlatHazardRate_dates;
*times = *QuantLibc::PiecewiseFlatHazardRate_times;
*nodes = *QuantLibc::PiecewiseFlatHazardRate_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PiecewiseFlatHazardRate($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Protection ##############

package QuantLib::Protection;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Buyer = *QuantLibc::Protection_Buyer;
*Seller = *QuantLibc::Protection_Seller;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Protection(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Protection($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CreditDefaultSwap ##############

package QuantLib::CreditDefaultSwap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CreditDefaultSwap(@_);
    bless $self, $pkg if defined($self);
}

*side = *QuantLibc::CreditDefaultSwap_side;
*notional = *QuantLibc::CreditDefaultSwap_notional;
*runningSpread = *QuantLibc::CreditDefaultSwap_runningSpread;
*upfront = *QuantLibc::CreditDefaultSwap_upfront;
*settlesAccrual = *QuantLibc::CreditDefaultSwap_settlesAccrual;
*paysAtDefaultTime = *QuantLibc::CreditDefaultSwap_paysAtDefaultTime;
*fairSpread = *QuantLibc::CreditDefaultSwap_fairSpread;
*fairUpfront = *QuantLibc::CreditDefaultSwap_fairUpfront;
*couponLegBPS = *QuantLibc::CreditDefaultSwap_couponLegBPS;
*couponLegNPV = *QuantLibc::CreditDefaultSwap_couponLegNPV;
*defaultLegNPV = *QuantLibc::CreditDefaultSwap_defaultLegNPV;
*upfrontBPS = *QuantLibc::CreditDefaultSwap_upfrontBPS;
*upfrontNPV = *QuantLibc::CreditDefaultSwap_upfrontNPV;
*impliedHazardRate = *QuantLibc::CreditDefaultSwap_impliedHazardRate;
*coupons = *QuantLibc::CreditDefaultSwap_coupons;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CreditDefaultSwap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MidPointCdsEngine ##############

package QuantLib::MidPointCdsEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MidPointCdsEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MidPointCdsEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IntegralCdsEngine ##############

package QuantLib::IntegralCdsEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IntegralCdsEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IntegralCdsEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DiscountCurve ##############

package QuantLib::DiscountCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DiscountCurve(@_);
    bless $self, $pkg if defined($self);
}

*times = *QuantLibc::DiscountCurve_times;
*data = *QuantLibc::DiscountCurve_data;
*dates = *QuantLibc::DiscountCurve_dates;
*discounts = *QuantLibc::DiscountCurve_discounts;
*nodes = *QuantLibc::DiscountCurve_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DiscountCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NormalDistribution ##############

package QuantLib::NormalDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NormalDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::NormalDistribution_call;
*derivative = *QuantLibc::NormalDistribution_derivative;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NormalDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CumulativeNormalDistribution ##############

package QuantLib::CumulativeNormalDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CumulativeNormalDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::CumulativeNormalDistribution_call;
*derivative = *QuantLibc::CumulativeNormalDistribution_derivative;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CumulativeNormalDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InverseCumulativeNormal ##############

package QuantLib::InverseCumulativeNormal;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InverseCumulativeNormal(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::InverseCumulativeNormal_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InverseCumulativeNormal($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MoroInverseCumulativeNormal ##############

package QuantLib::MoroInverseCumulativeNormal;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MoroInverseCumulativeNormal(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::MoroInverseCumulativeNormal_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MoroInverseCumulativeNormal($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BivariateCumulativeNormalDistribution ##############

package QuantLib::BivariateCumulativeNormalDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BivariateCumulativeNormalDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::BivariateCumulativeNormalDistribution_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BivariateCumulativeNormalDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BinomialDistribution ##############

package QuantLib::BinomialDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BinomialDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::BinomialDistribution_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BinomialDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CumulativeBinomialDistribution ##############

package QuantLib::CumulativeBinomialDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CumulativeBinomialDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::CumulativeBinomialDistribution_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CumulativeBinomialDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BivariateCumulativeNormalDistributionDr78 ##############

package QuantLib::BivariateCumulativeNormalDistributionDr78;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BivariateCumulativeNormalDistributionDr78(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::BivariateCumulativeNormalDistributionDr78_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BivariateCumulativeNormalDistributionDr78($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BivariateCumulativeNormalDistributionWe04DP ##############

package QuantLib::BivariateCumulativeNormalDistributionWe04DP;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BivariateCumulativeNormalDistributionWe04DP(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::BivariateCumulativeNormalDistributionWe04DP_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BivariateCumulativeNormalDistributionWe04DP($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CumulativeChiSquareDistribution ##############

package QuantLib::CumulativeChiSquareDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CumulativeChiSquareDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::CumulativeChiSquareDistribution_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CumulativeChiSquareDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NonCentralCumulativeChiSquareDistribution ##############

package QuantLib::NonCentralCumulativeChiSquareDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NonCentralCumulativeChiSquareDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::NonCentralCumulativeChiSquareDistribution_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NonCentralCumulativeChiSquareDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InverseNonCentralCumulativeChiSquareDistribution ##############

package QuantLib::InverseNonCentralCumulativeChiSquareDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InverseNonCentralCumulativeChiSquareDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::InverseNonCentralCumulativeChiSquareDistribution_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InverseNonCentralCumulativeChiSquareDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CumulativeGammaDistribution ##############

package QuantLib::CumulativeGammaDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CumulativeGammaDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::CumulativeGammaDistribution_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CumulativeGammaDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GammaFunction ##############

package QuantLib::GammaFunction;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*logValue = *QuantLibc::GammaFunction_logValue;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GammaFunction(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GammaFunction($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PoissonDistribution ##############

package QuantLib::PoissonDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PoissonDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::PoissonDistribution_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PoissonDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CumulativePoissonDistribution ##############

package QuantLib::CumulativePoissonDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CumulativePoissonDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::CumulativePoissonDistribution_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CumulativePoissonDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InverseCumulativePoisson ##############

package QuantLib::InverseCumulativePoisson;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InverseCumulativePoisson(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::InverseCumulativePoisson_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InverseCumulativePoisson($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::StudentDistribution ##############

package QuantLib::StudentDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_StudentDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::StudentDistribution_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_StudentDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CumulativeStudentDistribution ##############

package QuantLib::CumulativeStudentDistribution;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CumulativeStudentDistribution(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::CumulativeStudentDistribution_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CumulativeStudentDistribution($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InverseCumulativeStudent ##############

package QuantLib::InverseCumulativeStudent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InverseCumulativeStudent(@_);
    bless $self, $pkg if defined($self);
}

*call = *QuantLibc::InverseCumulativeStudent_call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InverseCumulativeStudent($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Money ##############

package QuantLib::Money;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Money(@_);
    bless $self, $pkg if defined($self);
}

*currency = *QuantLibc::Money_currency;
*value = *QuantLibc::Money_value;
*rounded = *QuantLibc::Money_rounded;
*NoConversion = *QuantLibc::Money_NoConversion;
*BaseCurrencyConversion = *QuantLibc::Money_BaseCurrencyConversion;
*AutomatedConversion = *QuantLibc::Money_AutomatedConversion;
*setConversionType = *QuantLibc::Money_setConversionType;
*setBaseCurrency = *QuantLibc::Money_setBaseCurrency;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Money($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ExchangeRate ##############

package QuantLib::ExchangeRate;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Direct = *QuantLibc::ExchangeRate_Direct;
*Derived = *QuantLibc::ExchangeRate_Derived;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ExchangeRate(@_);
    bless $self, $pkg if defined($self);
}

*source = *QuantLibc::ExchangeRate_source;
*target = *QuantLibc::ExchangeRate_target;
*type = *QuantLibc::ExchangeRate_type;
*rate = *QuantLibc::ExchangeRate_rate;
*exchange = *QuantLibc::ExchangeRate_exchange;
*chain = *QuantLibc::ExchangeRate_chain;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ExchangeRate($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ExchangeRateManager ##############

package QuantLib::ExchangeRateManager;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*instance = *QuantLibc::ExchangeRateManager_instance;
*add = *QuantLibc::ExchangeRateManager_add;
*lookup = *QuantLibc::ExchangeRateManager_lookup;
*clear = *QuantLibc::ExchangeRateManager_clear;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ExchangeRateManager($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Futures ##############

package QuantLib::Futures;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*IMM = *QuantLibc::Futures_IMM;
*ASX = *QuantLibc::Futures_ASX;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Futures(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Futures($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TimeBasket ##############

package QuantLib::TimeBasket;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TimeBasket(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::TimeBasket_size;
*rebin = *QuantLibc::TimeBasket_rebin;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TimeBasket($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Swap ##############

package QuantLib::Swap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Swap(@_);
    bless $self, $pkg if defined($self);
}

*startDate = *QuantLibc::Swap_startDate;
*maturityDate = *QuantLibc::Swap_maturityDate;
*leg = *QuantLibc::Swap_leg;
*legNPV = *QuantLibc::Swap_legNPV;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Swap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::VanillaSwap ##############

package QuantLib::VanillaSwap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Swap QuantLib );
%OWNER = ();
%ITERATORS = ();
*Receiver = *QuantLibc::VanillaSwap_Receiver;
*Receiver = *QuantLibc::VanillaSwap_Receiver;
*Payer = *QuantLibc::VanillaSwap_Payer;
*Payer = *QuantLibc::VanillaSwap_Payer;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_VanillaSwap(@_);
    bless $self, $pkg if defined($self);
}

*fairRate = *QuantLibc::VanillaSwap_fairRate;
*fairSpread = *QuantLibc::VanillaSwap_fairSpread;
*fixedLegBPS = *QuantLibc::VanillaSwap_fixedLegBPS;
*floatingLegBPS = *QuantLibc::VanillaSwap_floatingLegBPS;
*fixedLegNPV = *QuantLibc::VanillaSwap_fixedLegNPV;
*floatingLegNPV = *QuantLibc::VanillaSwap_floatingLegNPV;
*fixedLeg = *QuantLibc::VanillaSwap_fixedLeg;
*floatingLeg = *QuantLibc::VanillaSwap_floatingLeg;
*nominal = *QuantLibc::VanillaSwap_nominal;
*fixedSchedule = *QuantLibc::VanillaSwap_fixedSchedule;
*floatingSchedule = *QuantLibc::VanillaSwap_floatingSchedule;
*fixedRate = *QuantLibc::VanillaSwap_fixedRate;
*spread = *QuantLibc::VanillaSwap_spread;
*floatingDayCount = *QuantLibc::VanillaSwap_floatingDayCount;
*fixedDayCount = *QuantLibc::VanillaSwap_fixedDayCount;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_VanillaSwap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NonstandardSwap ##############

package QuantLib::NonstandardSwap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Swap QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NonstandardSwap(@_);
    bless $self, $pkg if defined($self);
}

*fixedLeg = *QuantLibc::NonstandardSwap_fixedLeg;
*floatingLeg = *QuantLibc::NonstandardSwap_floatingLeg;
*fixedNominals = *QuantLibc::NonstandardSwap_fixedNominals;
*floatingNominals = *QuantLibc::NonstandardSwap_floatingNominals;
*fixedSchedule = *QuantLibc::NonstandardSwap_fixedSchedule;
*floatingSchedule = *QuantLibc::NonstandardSwap_floatingSchedule;
*fixedRate = *QuantLibc::NonstandardSwap_fixedRate;
*spreads = *QuantLibc::NonstandardSwap_spreads;
*gearings = *QuantLibc::NonstandardSwap_gearings;
*floatingDayCount = *QuantLibc::NonstandardSwap_floatingDayCount;
*fixedDayCount = *QuantLibc::NonstandardSwap_fixedDayCount;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NonstandardSwap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DiscountingSwapEngine ##############

package QuantLib::DiscountingSwapEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DiscountingSwapEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DiscountingSwapEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::AssetSwap ##############

package QuantLib::AssetSwap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Swap QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_AssetSwap(@_);
    bless $self, $pkg if defined($self);
}

*fairCleanPrice = *QuantLibc::AssetSwap_fairCleanPrice;
*fairSpread = *QuantLibc::AssetSwap_fairSpread;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_AssetSwap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FloatFloatSwap ##############

package QuantLib::FloatFloatSwap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Swap QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FloatFloatSwap(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FloatFloatSwap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::OvernightIndexedSwap ##############

package QuantLib::OvernightIndexedSwap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Swap QuantLib );
%OWNER = ();
%ITERATORS = ();
*Receiver = *QuantLibc::OvernightIndexedSwap_Receiver;
*Receiver = *QuantLibc::OvernightIndexedSwap_Receiver;
*Payer = *QuantLibc::OvernightIndexedSwap_Payer;
*Payer = *QuantLibc::OvernightIndexedSwap_Payer;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_OvernightIndexedSwap(@_);
    bless $self, $pkg if defined($self);
}

*fixedLegBPS = *QuantLibc::OvernightIndexedSwap_fixedLegBPS;
*fixedLegNPV = *QuantLibc::OvernightIndexedSwap_fixedLegNPV;
*fairRate = *QuantLibc::OvernightIndexedSwap_fairRate;
*overnightLegBPS = *QuantLibc::OvernightIndexedSwap_overnightLegBPS;
*overnightLegNPV = *QuantLibc::OvernightIndexedSwap_overnightLegNPV;
*fairSpread = *QuantLibc::OvernightIndexedSwap_fairSpread;
*type = *QuantLibc::OvernightIndexedSwap_type;
*nominal = *QuantLibc::OvernightIndexedSwap_nominal;
*nominals = *QuantLibc::OvernightIndexedSwap_nominals;
*paymentFrequency = *QuantLibc::OvernightIndexedSwap_paymentFrequency;
*fixedRate = *QuantLibc::OvernightIndexedSwap_fixedRate;
*fixedDayCount = *QuantLibc::OvernightIndexedSwap_fixedDayCount;
*spread = *QuantLibc::OvernightIndexedSwap_spread;
*fixedLeg = *QuantLibc::OvernightIndexedSwap_fixedLeg;
*overnightLeg = *QuantLibc::OvernightIndexedSwap_overnightLeg;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_OvernightIndexedSwap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Pillar ##############

package QuantLib::Pillar;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*MaturityDate = *QuantLibc::Pillar_MaturityDate;
*LastRelevantDate = *QuantLibc::Pillar_LastRelevantDate;
*CustomDate = *QuantLibc::Pillar_CustomDate;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Pillar(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Pillar($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RateHelper ##############

package QuantLib::RateHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::RateHelper___deref__;
*isNull = *QuantLibc::RateHelper_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RateHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RateHelper($self);
        delete $OWNER{$self};
    }
}

*quote = *QuantLibc::RateHelper_quote;
*latestDate = *QuantLibc::RateHelper_latestDate;
*earliestDate = *QuantLibc::RateHelper_earliestDate;
*maturityDate = *QuantLibc::RateHelper_maturityDate;
*latestRelevantDate = *QuantLibc::RateHelper_latestRelevantDate;
*pillarDate = *QuantLibc::RateHelper_pillarDate;
*impliedQuote = *QuantLibc::RateHelper_impliedQuote;
*quoteError = *QuantLibc::RateHelper_quoteError;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DepositRateHelper ##############

package QuantLib::DepositRateHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::RateHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DepositRateHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DepositRateHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FraRateHelper ##############

package QuantLib::FraRateHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::RateHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FraRateHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FraRateHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FuturesRateHelper ##############

package QuantLib::FuturesRateHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::RateHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FuturesRateHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FuturesRateHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SwapRateHelper ##############

package QuantLib::SwapRateHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::RateHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SwapRateHelper(@_);
    bless $self, $pkg if defined($self);
}

*spread = *QuantLibc::SwapRateHelper_spread;
*swap = *QuantLibc::SwapRateHelper_swap;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SwapRateHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BondHelper ##############

package QuantLib::BondHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::RateHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BondHelper(@_);
    bless $self, $pkg if defined($self);
}

*bond = *QuantLibc::BondHelper_bond;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BondHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FixedRateBondHelper ##############

package QuantLib::FixedRateBondHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::BondHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FixedRateBondHelper(@_);
    bless $self, $pkg if defined($self);
}

*bond = *QuantLibc::FixedRateBondHelper_bond;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FixedRateBondHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::OISRateHelper ##############

package QuantLib::OISRateHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::RateHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_OISRateHelper(@_);
    bless $self, $pkg if defined($self);
}

*impliedQuote = *QuantLibc::OISRateHelper_impliedQuote;
*swap = *QuantLibc::OISRateHelper_swap;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_OISRateHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DatedOISRateHelper ##############

package QuantLib::DatedOISRateHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::RateHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DatedOISRateHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DatedOISRateHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FxSwapRateHelper ##############

package QuantLib::FxSwapRateHelper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::RateHelper QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FxSwapRateHelper(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FxSwapRateHelper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RateHelperVector ##############

package QuantLib::RateHelperVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RateHelperVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::RateHelperVector_size;
*empty = *QuantLibc::RateHelperVector_empty;
*clear = *QuantLibc::RateHelperVector_clear;
*push = *QuantLibc::RateHelperVector_push;
*pop = *QuantLibc::RateHelperVector_pop;
*get = *QuantLibc::RateHelperVector_get;
*set = *QuantLibc::RateHelperVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RateHelperVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FittingMethod ##############

package QuantLib::FittingMethod;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FittingMethod($self);
        delete $OWNER{$self};
    }
}

*size = *QuantLibc::FittingMethod_size;
*solution = *QuantLibc::FittingMethod_solution;
*numberOfIterations = *QuantLibc::FittingMethod_numberOfIterations;
*minimumCostValue = *QuantLibc::FittingMethod_minimumCostValue;
*constrainAtZero = *QuantLibc::FittingMethod_constrainAtZero;
*weights = *QuantLibc::FittingMethod_weights;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FittedBondDiscountCurve ##############

package QuantLib::FittedBondDiscountCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FittedBondDiscountCurve(@_);
    bless $self, $pkg if defined($self);
}

*fitResults = *QuantLibc::FittedBondDiscountCurve_fitResults;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FittedBondDiscountCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ExponentialSplinesFitting ##############

package QuantLib::ExponentialSplinesFitting;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::FittingMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ExponentialSplinesFitting(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ExponentialSplinesFitting($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NelsonSiegelFitting ##############

package QuantLib::NelsonSiegelFitting;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::FittingMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NelsonSiegelFitting(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NelsonSiegelFitting($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SvenssonFitting ##############

package QuantLib::SvenssonFitting;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::FittingMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SvenssonFitting(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SvenssonFitting($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CubicBSplinesFitting ##############

package QuantLib::CubicBSplinesFitting;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::FittingMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CubicBSplinesFitting(@_);
    bless $self, $pkg if defined($self);
}

*basisFunction = *QuantLibc::CubicBSplinesFitting_basisFunction;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CubicBSplinesFitting($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SimplePolynomialFitting ##############

package QuantLib::SimplePolynomialFitting;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::FittingMethod QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SimplePolynomialFitting(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SimplePolynomialFitting($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ForwardCurve ##############

package QuantLib::ForwardCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ForwardCurve(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::ForwardCurve_dates;
*forwards = *QuantLibc::ForwardCurve_forwards;
*nodes = *QuantLibc::ForwardCurve_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ForwardCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Position ##############

package QuantLib::Position;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Long = *QuantLibc::Position_Long;
*Short = *QuantLibc::Position_Short;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Position(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Position($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ForwardRateAgreement ##############

package QuantLib::ForwardRateAgreement;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ForwardRateAgreement(@_);
    bless $self, $pkg if defined($self);
}

*spotIncome = *QuantLibc::ForwardRateAgreement_spotIncome;
*spotValue = *QuantLibc::ForwardRateAgreement_spotValue;
*forwardRate = *QuantLibc::ForwardRateAgreement_forwardRate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ForwardRateAgreement($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Gaussian1dModel ##############

package QuantLib::Gaussian1dModel;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::Gaussian1dModel___deref__;
*isNull = *QuantLibc::Gaussian1dModel_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Gaussian1dModel(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Gaussian1dModel($self);
        delete $OWNER{$self};
    }
}

*stateProcess = *QuantLibc::Gaussian1dModel_stateProcess;
*numeraire = *QuantLibc::Gaussian1dModel_numeraire;
*zerobond = *QuantLibc::Gaussian1dModel_zerobond;
*zerobondOption = *QuantLibc::Gaussian1dModel_zerobondOption;
*forwardRate = *QuantLibc::Gaussian1dModel_forwardRate;
*swapRate = *QuantLibc::Gaussian1dModel_swapRate;
*swapAnnuity = *QuantLibc::Gaussian1dModel_swapAnnuity;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Gsr ##############

package QuantLib::Gsr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Gaussian1dModel QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Gsr(@_);
    bless $self, $pkg if defined($self);
}

*calibrateVolatilitiesIterative = *QuantLibc::Gsr_calibrateVolatilitiesIterative;
*calibrate = *QuantLibc::Gsr_calibrate;
*params = *QuantLibc::Gsr_params;
*value = *QuantLibc::Gsr_value;
*endCriteria = *QuantLibc::Gsr_endCriteria;
*setParams = *QuantLibc::Gsr_setParams;
*functionEvaluation = *QuantLibc::Gsr_functionEvaluation;
*reversion = *QuantLibc::Gsr_reversion;
*volatility = *QuantLibc::Gsr_volatility;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Gsr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MarkovFunctionalSettings ##############

package QuantLib::MarkovFunctionalSettings;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*AdjustNone = *QuantLibc::MarkovFunctionalSettings_AdjustNone;
*AdjustDigitals = *QuantLibc::MarkovFunctionalSettings_AdjustDigitals;
*AdjustYts = *QuantLibc::MarkovFunctionalSettings_AdjustYts;
*ExtrapolatePayoffFlat = *QuantLibc::MarkovFunctionalSettings_ExtrapolatePayoffFlat;
*NoPayoffExtrapolation = *QuantLibc::MarkovFunctionalSettings_NoPayoffExtrapolation;
*KahaleSmile = *QuantLibc::MarkovFunctionalSettings_KahaleSmile;
*SmileExponentialExtrapolation = *QuantLibc::MarkovFunctionalSettings_SmileExponentialExtrapolation;
*KahaleInterpolation = *QuantLibc::MarkovFunctionalSettings_KahaleInterpolation;
*SmileDeleteArbitragePoints = *QuantLibc::MarkovFunctionalSettings_SmileDeleteArbitragePoints;
*SabrSmile = *QuantLibc::MarkovFunctionalSettings_SabrSmile;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MarkovFunctionalSettings(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MarkovFunctionalSettings($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MarkovFunctional ##############

package QuantLib::MarkovFunctional;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Gaussian1dModel QuantLib );
%OWNER = ();
%ITERATORS = ();
*AdjustNone = *QuantLibc::MarkovFunctional_AdjustNone;
*AdjustNone = *QuantLibc::MarkovFunctional_AdjustNone;
*AdjustDigitals = *QuantLibc::MarkovFunctional_AdjustDigitals;
*AdjustDigitals = *QuantLibc::MarkovFunctional_AdjustDigitals;
*AdjustYts = *QuantLibc::MarkovFunctional_AdjustYts;
*AdjustYts = *QuantLibc::MarkovFunctional_AdjustYts;
*ExtrapolatePayoffFlat = *QuantLibc::MarkovFunctional_ExtrapolatePayoffFlat;
*ExtrapolatePayoffFlat = *QuantLibc::MarkovFunctional_ExtrapolatePayoffFlat;
*NoPayoffExtrapolation = *QuantLibc::MarkovFunctional_NoPayoffExtrapolation;
*NoPayoffExtrapolation = *QuantLibc::MarkovFunctional_NoPayoffExtrapolation;
*KahaleSmile = *QuantLibc::MarkovFunctional_KahaleSmile;
*KahaleSmile = *QuantLibc::MarkovFunctional_KahaleSmile;
*SmileExponentialExtrapolation = *QuantLibc::MarkovFunctional_SmileExponentialExtrapolation;
*SmileExponentialExtrapolation = *QuantLibc::MarkovFunctional_SmileExponentialExtrapolation;
*KahaleInterpolation = *QuantLibc::MarkovFunctional_KahaleInterpolation;
*KahaleInterpolation = *QuantLibc::MarkovFunctional_KahaleInterpolation;
*SmileDeleteArbitragePoints = *QuantLibc::MarkovFunctional_SmileDeleteArbitragePoints;
*SmileDeleteArbitragePoints = *QuantLibc::MarkovFunctional_SmileDeleteArbitragePoints;
*SabrSmile = *QuantLibc::MarkovFunctional_SabrSmile;
*SabrSmile = *QuantLibc::MarkovFunctional_SabrSmile;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MarkovFunctional(@_);
    bless $self, $pkg if defined($self);
}

*calibrate = *QuantLibc::MarkovFunctional_calibrate;
*volatility = *QuantLibc::MarkovFunctional_volatility;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MarkovFunctional($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Gaussian1dSwaptionEngine ##############

package QuantLib::Gaussian1dSwaptionEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
*None = *QuantLibc::Gaussian1dSwaptionEngine_None;
*None = *QuantLibc::Gaussian1dSwaptionEngine_None;
*Naive = *QuantLibc::Gaussian1dSwaptionEngine_Naive;
*Naive = *QuantLibc::Gaussian1dSwaptionEngine_Naive;
*Digital = *QuantLibc::Gaussian1dSwaptionEngine_Digital;
*Digital = *QuantLibc::Gaussian1dSwaptionEngine_Digital;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Gaussian1dSwaptionEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Gaussian1dSwaptionEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Gaussian1dJamshidianSwaptionEngine ##############

package QuantLib::Gaussian1dJamshidianSwaptionEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Gaussian1dJamshidianSwaptionEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Gaussian1dJamshidianSwaptionEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Gaussian1dNonstandardSwaptionEngine ##############

package QuantLib::Gaussian1dNonstandardSwaptionEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
*None = *QuantLibc::Gaussian1dNonstandardSwaptionEngine_None;
*None = *QuantLibc::Gaussian1dNonstandardSwaptionEngine_None;
*Naive = *QuantLibc::Gaussian1dNonstandardSwaptionEngine_Naive;
*Naive = *QuantLibc::Gaussian1dNonstandardSwaptionEngine_Naive;
*Digital = *QuantLibc::Gaussian1dNonstandardSwaptionEngine_Digital;
*Digital = *QuantLibc::Gaussian1dNonstandardSwaptionEngine_Digital;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Gaussian1dNonstandardSwaptionEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Gaussian1dNonstandardSwaptionEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Gaussian1dFloatFloatSwaptionEngine ##############

package QuantLib::Gaussian1dFloatFloatSwaptionEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
*None = *QuantLibc::Gaussian1dFloatFloatSwaptionEngine_None;
*None = *QuantLibc::Gaussian1dFloatFloatSwaptionEngine_None;
*Naive = *QuantLibc::Gaussian1dFloatFloatSwaptionEngine_Naive;
*Naive = *QuantLibc::Gaussian1dFloatFloatSwaptionEngine_Naive;
*Digital = *QuantLibc::Gaussian1dFloatFloatSwaptionEngine_Digital;
*Digital = *QuantLibc::Gaussian1dFloatFloatSwaptionEngine_Digital;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Gaussian1dFloatFloatSwaptionEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Gaussian1dFloatFloatSwaptionEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SegmentIntegral ##############

package QuantLib::SegmentIntegral;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SegmentIntegral(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SegmentIntegral($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TrapezoidIntegralDefault ##############

package QuantLib::TrapezoidIntegralDefault;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TrapezoidIntegralDefault(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TrapezoidIntegralDefault($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TrapezoidIntegralMidPoint ##############

package QuantLib::TrapezoidIntegralMidPoint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TrapezoidIntegralMidPoint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TrapezoidIntegralMidPoint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SimpsonIntegral ##############

package QuantLib::SimpsonIntegral;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SimpsonIntegral(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SimpsonIntegral($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussKronrodAdaptive ##############

package QuantLib::GaussKronrodAdaptive;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussKronrodAdaptive(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussKronrodAdaptive($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussKronrodNonAdaptive ##############

package QuantLib::GaussKronrodNonAdaptive;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussKronrodNonAdaptive(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussKronrodNonAdaptive($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussLobattoIntegral ##############

package QuantLib::GaussLobattoIntegral;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussLobattoIntegral(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussLobattoIntegral($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussLaguerreIntegration ##############

package QuantLib::GaussLaguerreIntegration;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussLaguerreIntegration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussLaguerreIntegration($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussHermiteIntegration ##############

package QuantLib::GaussHermiteIntegration;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussHermiteIntegration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussHermiteIntegration($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussJacobiIntegration ##############

package QuantLib::GaussJacobiIntegration;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussJacobiIntegration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussJacobiIntegration($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussHyperbolicIntegration ##############

package QuantLib::GaussHyperbolicIntegration;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussHyperbolicIntegration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussHyperbolicIntegration($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussLegendreIntegration ##############

package QuantLib::GaussLegendreIntegration;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussLegendreIntegration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussLegendreIntegration($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussChebyshevIntegration ##############

package QuantLib::GaussChebyshevIntegration;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussChebyshevIntegration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussChebyshevIntegration($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussChebyshev2ndIntegration ##############

package QuantLib::GaussChebyshev2ndIntegration;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussChebyshev2ndIntegration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussChebyshev2ndIntegration($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussGegenbauerIntegration ##############

package QuantLib::GaussGegenbauerIntegration;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussGegenbauerIntegration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussGegenbauerIntegration($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SampleNumber ##############

package QuantLib::SampleNumber;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*value = *QuantLibc::SampleNumber_value;
*weight = *QuantLibc::SampleNumber_weight;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SampleNumber($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SampleArray ##############

package QuantLib::SampleArray;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*value = *QuantLibc::SampleArray_value;
*weight = *QuantLibc::SampleArray_weight;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SampleArray($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SampleRealVector ##############

package QuantLib::SampleRealVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*value = *QuantLibc::SampleRealVector_value;
*weight = *QuantLibc::SampleRealVector_weight;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SampleRealVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LecuyerUniformRng ##############

package QuantLib::LecuyerUniformRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LecuyerUniformRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::LecuyerUniformRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LecuyerUniformRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::KnuthUniformRng ##############

package QuantLib::KnuthUniformRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_KnuthUniformRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::KnuthUniformRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_KnuthUniformRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MersenneTwisterUniformRng ##############

package QuantLib::MersenneTwisterUniformRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MersenneTwisterUniformRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::MersenneTwisterUniformRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MersenneTwisterUniformRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::UniformRandomGenerator ##############

package QuantLib::UniformRandomGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_UniformRandomGenerator(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::UniformRandomGenerator_next;
*nextValue = *QuantLibc::UniformRandomGenerator_nextValue;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_UniformRandomGenerator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CentralLimitLecuyerGaussianRng ##############

package QuantLib::CentralLimitLecuyerGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CentralLimitLecuyerGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::CentralLimitLecuyerGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CentralLimitLecuyerGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CentralLimitKnuthGaussianRng ##############

package QuantLib::CentralLimitKnuthGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CentralLimitKnuthGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::CentralLimitKnuthGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CentralLimitKnuthGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CentralLimitMersenneTwisterGaussianRng ##############

package QuantLib::CentralLimitMersenneTwisterGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CentralLimitMersenneTwisterGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::CentralLimitMersenneTwisterGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CentralLimitMersenneTwisterGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BoxMullerLecuyerGaussianRng ##############

package QuantLib::BoxMullerLecuyerGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BoxMullerLecuyerGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::BoxMullerLecuyerGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BoxMullerLecuyerGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BoxMullerKnuthGaussianRng ##############

package QuantLib::BoxMullerKnuthGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BoxMullerKnuthGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::BoxMullerKnuthGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BoxMullerKnuthGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BoxMullerMersenneTwisterGaussianRng ##############

package QuantLib::BoxMullerMersenneTwisterGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BoxMullerMersenneTwisterGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::BoxMullerMersenneTwisterGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BoxMullerMersenneTwisterGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MoroInvCumulativeLecuyerGaussianRng ##############

package QuantLib::MoroInvCumulativeLecuyerGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MoroInvCumulativeLecuyerGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::MoroInvCumulativeLecuyerGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MoroInvCumulativeLecuyerGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MoroInvCumulativeKnuthGaussianRng ##############

package QuantLib::MoroInvCumulativeKnuthGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MoroInvCumulativeKnuthGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::MoroInvCumulativeKnuthGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MoroInvCumulativeKnuthGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MoroInvCumulativeMersenneTwisterGaussianRng ##############

package QuantLib::MoroInvCumulativeMersenneTwisterGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MoroInvCumulativeMersenneTwisterGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::MoroInvCumulativeMersenneTwisterGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MoroInvCumulativeMersenneTwisterGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InvCumulativeLecuyerGaussianRng ##############

package QuantLib::InvCumulativeLecuyerGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InvCumulativeLecuyerGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::InvCumulativeLecuyerGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InvCumulativeLecuyerGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InvCumulativeKnuthGaussianRng ##############

package QuantLib::InvCumulativeKnuthGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InvCumulativeKnuthGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::InvCumulativeKnuthGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InvCumulativeKnuthGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InvCumulativeMersenneTwisterGaussianRng ##############

package QuantLib::InvCumulativeMersenneTwisterGaussianRng;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InvCumulativeMersenneTwisterGaussianRng(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::InvCumulativeMersenneTwisterGaussianRng_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InvCumulativeMersenneTwisterGaussianRng($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussianRandomGenerator ##############

package QuantLib::GaussianRandomGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussianRandomGenerator(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::GaussianRandomGenerator_next;
*nextValue = *QuantLibc::GaussianRandomGenerator_nextValue;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussianRandomGenerator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::HaltonRsg ##############

package QuantLib::HaltonRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_HaltonRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::HaltonRsg_nextSequence;
*lastSequence = *QuantLibc::HaltonRsg_lastSequence;
*dimension = *QuantLibc::HaltonRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_HaltonRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SobolRsg ##############

package QuantLib::SobolRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Unit = *QuantLibc::SobolRsg_Unit;
*Jaeckel = *QuantLibc::SobolRsg_Jaeckel;
*SobolLevitan = *QuantLibc::SobolRsg_SobolLevitan;
*SobolLevitanLemieux = *QuantLibc::SobolRsg_SobolLevitanLemieux;
*JoeKuoD5 = *QuantLibc::SobolRsg_JoeKuoD5;
*JoeKuoD6 = *QuantLibc::SobolRsg_JoeKuoD6;
*JoeKuoD7 = *QuantLibc::SobolRsg_JoeKuoD7;
*Kuo = *QuantLibc::SobolRsg_Kuo;
*Kuo2 = *QuantLibc::SobolRsg_Kuo2;
*Kuo3 = *QuantLibc::SobolRsg_Kuo3;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SobolRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::SobolRsg_nextSequence;
*lastSequence = *QuantLibc::SobolRsg_lastSequence;
*dimension = *QuantLibc::SobolRsg_dimension;
*skipTo = *QuantLibc::SobolRsg_skipTo;
*nextInt32Sequence = *QuantLibc::SobolRsg_nextInt32Sequence;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SobolRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SobolBrownianBridgeRsg ##############

package QuantLib::SobolBrownianBridgeRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SobolBrownianBridgeRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::SobolBrownianBridgeRsg_nextSequence;
*lastSequence = *QuantLibc::SobolBrownianBridgeRsg_lastSequence;
*dimension = *QuantLibc::SobolBrownianBridgeRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SobolBrownianBridgeRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LecuyerUniformRsg ##############

package QuantLib::LecuyerUniformRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LecuyerUniformRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::LecuyerUniformRsg_nextSequence;
*dimension = *QuantLibc::LecuyerUniformRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LecuyerUniformRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::KnuthUniformRsg ##############

package QuantLib::KnuthUniformRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_KnuthUniformRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::KnuthUniformRsg_nextSequence;
*dimension = *QuantLibc::KnuthUniformRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_KnuthUniformRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MersenneTwisterUniformRsg ##############

package QuantLib::MersenneTwisterUniformRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MersenneTwisterUniformRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::MersenneTwisterUniformRsg_nextSequence;
*dimension = *QuantLibc::MersenneTwisterUniformRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MersenneTwisterUniformRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::UniformRandomSequenceGenerator ##############

package QuantLib::UniformRandomSequenceGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_UniformRandomSequenceGenerator(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::UniformRandomSequenceGenerator_nextSequence;
*dimension = *QuantLibc::UniformRandomSequenceGenerator_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_UniformRandomSequenceGenerator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::UniformLowDiscrepancySequenceGenerator ##############

package QuantLib::UniformLowDiscrepancySequenceGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_UniformLowDiscrepancySequenceGenerator(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::UniformLowDiscrepancySequenceGenerator_nextSequence;
*dimension = *QuantLibc::UniformLowDiscrepancySequenceGenerator_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_UniformLowDiscrepancySequenceGenerator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MoroInvCumulativeLecuyerGaussianRsg ##############

package QuantLib::MoroInvCumulativeLecuyerGaussianRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MoroInvCumulativeLecuyerGaussianRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::MoroInvCumulativeLecuyerGaussianRsg_nextSequence;
*dimension = *QuantLibc::MoroInvCumulativeLecuyerGaussianRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MoroInvCumulativeLecuyerGaussianRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MoroInvCumulativeKnuthGaussianRsg ##############

package QuantLib::MoroInvCumulativeKnuthGaussianRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MoroInvCumulativeKnuthGaussianRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::MoroInvCumulativeKnuthGaussianRsg_nextSequence;
*dimension = *QuantLibc::MoroInvCumulativeKnuthGaussianRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MoroInvCumulativeKnuthGaussianRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MoroInvCumulativeMersenneTwisterGaussianRsg ##############

package QuantLib::MoroInvCumulativeMersenneTwisterGaussianRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MoroInvCumulativeMersenneTwisterGaussianRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::MoroInvCumulativeMersenneTwisterGaussianRsg_nextSequence;
*dimension = *QuantLibc::MoroInvCumulativeMersenneTwisterGaussianRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MoroInvCumulativeMersenneTwisterGaussianRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MoroInvCumulativeHaltonGaussianRsg ##############

package QuantLib::MoroInvCumulativeHaltonGaussianRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MoroInvCumulativeHaltonGaussianRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::MoroInvCumulativeHaltonGaussianRsg_nextSequence;
*dimension = *QuantLibc::MoroInvCumulativeHaltonGaussianRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MoroInvCumulativeHaltonGaussianRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MoroInvCumulativeSobolGaussianRsg ##############

package QuantLib::MoroInvCumulativeSobolGaussianRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MoroInvCumulativeSobolGaussianRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::MoroInvCumulativeSobolGaussianRsg_nextSequence;
*dimension = *QuantLibc::MoroInvCumulativeSobolGaussianRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MoroInvCumulativeSobolGaussianRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InvCumulativeLecuyerGaussianRsg ##############

package QuantLib::InvCumulativeLecuyerGaussianRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InvCumulativeLecuyerGaussianRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::InvCumulativeLecuyerGaussianRsg_nextSequence;
*dimension = *QuantLibc::InvCumulativeLecuyerGaussianRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InvCumulativeLecuyerGaussianRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InvCumulativeKnuthGaussianRsg ##############

package QuantLib::InvCumulativeKnuthGaussianRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InvCumulativeKnuthGaussianRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::InvCumulativeKnuthGaussianRsg_nextSequence;
*dimension = *QuantLibc::InvCumulativeKnuthGaussianRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InvCumulativeKnuthGaussianRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InvCumulativeMersenneTwisterGaussianRsg ##############

package QuantLib::InvCumulativeMersenneTwisterGaussianRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InvCumulativeMersenneTwisterGaussianRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::InvCumulativeMersenneTwisterGaussianRsg_nextSequence;
*dimension = *QuantLibc::InvCumulativeMersenneTwisterGaussianRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InvCumulativeMersenneTwisterGaussianRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InvCumulativeHaltonGaussianRsg ##############

package QuantLib::InvCumulativeHaltonGaussianRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InvCumulativeHaltonGaussianRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::InvCumulativeHaltonGaussianRsg_nextSequence;
*dimension = *QuantLibc::InvCumulativeHaltonGaussianRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InvCumulativeHaltonGaussianRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::InvCumulativeSobolGaussianRsg ##############

package QuantLib::InvCumulativeSobolGaussianRsg;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_InvCumulativeSobolGaussianRsg(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::InvCumulativeSobolGaussianRsg_nextSequence;
*dimension = *QuantLibc::InvCumulativeSobolGaussianRsg_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_InvCumulativeSobolGaussianRsg($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussianRandomSequenceGenerator ##############

package QuantLib::GaussianRandomSequenceGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussianRandomSequenceGenerator(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::GaussianRandomSequenceGenerator_nextSequence;
*dimension = *QuantLibc::GaussianRandomSequenceGenerator_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussianRandomSequenceGenerator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussianLowDiscrepancySequenceGenerator ##############

package QuantLib::GaussianLowDiscrepancySequenceGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussianLowDiscrepancySequenceGenerator(@_);
    bless $self, $pkg if defined($self);
}

*nextSequence = *QuantLibc::GaussianLowDiscrepancySequenceGenerator_nextSequence;
*dimension = *QuantLibc::GaussianLowDiscrepancySequenceGenerator_dimension;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussianLowDiscrepancySequenceGenerator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Path ##############

package QuantLib::Path;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*length = *QuantLibc::Path_length;
*value = *QuantLibc::Path_value;
*front = *QuantLibc::Path_front;
*back = *QuantLibc::Path_back;
*time = *QuantLibc::Path_time;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Path($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SamplePath ##############

package QuantLib::SamplePath;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*value = *QuantLibc::SamplePath_value;
*weight = *QuantLibc::SamplePath_weight;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SamplePath($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussianPathGenerator ##############

package QuantLib::GaussianPathGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussianPathGenerator(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::GaussianPathGenerator_next;
*antithetic = *QuantLibc::GaussianPathGenerator_antithetic;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussianPathGenerator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussianSobolPathGenerator ##############

package QuantLib::GaussianSobolPathGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussianSobolPathGenerator(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::GaussianSobolPathGenerator_next;
*antithetic = *QuantLibc::GaussianSobolPathGenerator_antithetic;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussianSobolPathGenerator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MultiPath ##############

package QuantLib::MultiPath;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*pathSize = *QuantLibc::MultiPath_pathSize;
*assetNumber = *QuantLibc::MultiPath_assetNumber;
*at = *QuantLibc::MultiPath_at;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MultiPath($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SampleMultiPath ##############

package QuantLib::SampleMultiPath;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*value = *QuantLibc::SampleMultiPath_value;
*weight = *QuantLibc::SampleMultiPath_weight;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SampleMultiPath($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GaussianMultiPathGenerator ##############

package QuantLib::GaussianMultiPathGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GaussianMultiPathGenerator(@_);
    bless $self, $pkg if defined($self);
}

*next = *QuantLibc::GaussianMultiPathGenerator_next;
*antithetic = *QuantLibc::GaussianMultiPathGenerator_antithetic;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GaussianMultiPathGenerator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BrownianBridge ##############

package QuantLib::BrownianBridge;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BrownianBridge(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::BrownianBridge_size;
*times = *QuantLibc::BrownianBridge_times;
*leftWeight = *QuantLibc::BrownianBridge_leftWeight;
*rightWeight = *QuantLibc::BrownianBridge_rightWeight;
*stdDeviation = *QuantLibc::BrownianBridge_stdDeviation;
*transform = *QuantLibc::BrownianBridge_transform;
*bridgeIndex = *QuantLibc::BrownianBridge_bridgeIndex;
*leftIndex = *QuantLibc::BrownianBridge_leftIndex;
*rightIndex = *QuantLibc::BrownianBridge_rightIndex;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BrownianBridge($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BoundaryCondition ##############

package QuantLib::BoundaryCondition;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::BoundaryCondition___deref__;
*isNull = *QuantLibc::BoundaryCondition_isNull;
*NoSide = *QuantLibc::BoundaryCondition_NoSide;
*NoSide = *QuantLibc::BoundaryCondition_NoSide;
*Upper = *QuantLibc::BoundaryCondition_Upper;
*Upper = *QuantLibc::BoundaryCondition_Upper;
*Lower = *QuantLibc::BoundaryCondition_Lower;
*Lower = *QuantLibc::BoundaryCondition_Lower;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BoundaryCondition(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BoundaryCondition($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NeumannBC ##############

package QuantLib::NeumannBC;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::BoundaryCondition QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NeumannBC(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NeumannBC($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DirichletBC ##############

package QuantLib::DirichletBC;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::BoundaryCondition QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DirichletBC(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DirichletBC($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::TridiagonalOperator ##############

package QuantLib::TridiagonalOperator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_TridiagonalOperator(@_);
    bless $self, $pkg if defined($self);
}

*solveFor = *QuantLibc::TridiagonalOperator_solveFor;
*applyTo = *QuantLibc::TridiagonalOperator_applyTo;
*size = *QuantLibc::TridiagonalOperator_size;
*setFirstRow = *QuantLibc::TridiagonalOperator_setFirstRow;
*setMidRow = *QuantLibc::TridiagonalOperator_setMidRow;
*setMidRows = *QuantLibc::TridiagonalOperator_setMidRows;
*setLastRow = *QuantLibc::TridiagonalOperator_setLastRow;
*identity = *QuantLibc::TridiagonalOperator_identity;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_TridiagonalOperator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DPlus ##############

package QuantLib::DPlus;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::TridiagonalOperator QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DPlus(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DPlus($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DMinus ##############

package QuantLib::DMinus;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::TridiagonalOperator QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DMinus(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DMinus($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DZero ##############

package QuantLib::DZero;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::TridiagonalOperator QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DZero(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DZero($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::DPlusDMinus ##############

package QuantLib::DPlusDMinus;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::TridiagonalOperator QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_DPlusDMinus(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_DPlusDMinus($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Discount ##############

package QuantLib::Discount;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Discount(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Discount($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZeroYield ##############

package QuantLib::ZeroYield;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZeroYield(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZeroYield($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ForwardRate ##############

package QuantLib::ForwardRate;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ForwardRate(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ForwardRate($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PiecewiseFlatForward ##############

package QuantLib::PiecewiseFlatForward;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PiecewiseFlatForward(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::PiecewiseFlatForward_dates;
*times = *QuantLibc::PiecewiseFlatForward_times;
*nodes = *QuantLibc::PiecewiseFlatForward_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PiecewiseFlatForward($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PiecewiseLinearForward ##############

package QuantLib::PiecewiseLinearForward;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PiecewiseLinearForward(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::PiecewiseLinearForward_dates;
*times = *QuantLibc::PiecewiseLinearForward_times;
*nodes = *QuantLibc::PiecewiseLinearForward_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PiecewiseLinearForward($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PiecewiseLinearZero ##############

package QuantLib::PiecewiseLinearZero;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PiecewiseLinearZero(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::PiecewiseLinearZero_dates;
*times = *QuantLibc::PiecewiseLinearZero_times;
*nodes = *QuantLibc::PiecewiseLinearZero_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PiecewiseLinearZero($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PiecewiseCubicZero ##############

package QuantLib::PiecewiseCubicZero;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PiecewiseCubicZero(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::PiecewiseCubicZero_dates;
*times = *QuantLibc::PiecewiseCubicZero_times;
*nodes = *QuantLibc::PiecewiseCubicZero_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PiecewiseCubicZero($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::PiecewiseLogCubicDiscount ##############

package QuantLib::PiecewiseLogCubicDiscount;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_PiecewiseLogCubicDiscount(@_);
    bless $self, $pkg if defined($self);
}

*dates = *QuantLibc::PiecewiseLogCubicDiscount_dates;
*times = *QuantLibc::PiecewiseLogCubicDiscount_times;
*nodes = *QuantLibc::PiecewiseLogCubicDiscount_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_PiecewiseLogCubicDiscount($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SampledCurve ##############

package QuantLib::SampledCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SampledCurve(@_);
    bless $self, $pkg if defined($self);
}

*grid = *QuantLibc::SampledCurve_grid;
*values = *QuantLibc::SampledCurve_values;
*gridValue = *QuantLibc::SampledCurve_gridValue;
*value = *QuantLibc::SampledCurve_value;
*size = *QuantLibc::SampledCurve_size;
*empty = *QuantLibc::SampledCurve_empty;
*setGrid = *QuantLibc::SampledCurve_setGrid;
*setValues = *QuantLibc::SampledCurve_setValues;
*swap = *QuantLibc::SampledCurve_swap;
*setLogGrid = *QuantLibc::SampledCurve_setLogGrid;
*regridLogGrid = *QuantLibc::SampledCurve_regridLogGrid;
*shiftGrid = *QuantLibc::SampledCurve_shiftGrid;
*scaleGrid = *QuantLibc::SampledCurve_scaleGrid;
*regrid = *QuantLibc::SampledCurve_regrid;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SampledCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Settings ##############

package QuantLib::Settings;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*instance = *QuantLibc::Settings_instance;
*getEvaluationDate = *QuantLibc::Settings_getEvaluationDate;
*setEvaluationDate = *QuantLibc::Settings_setEvaluationDate;
*includeReferenceDateEvents = *QuantLibc::Settings_includeReferenceDateEvents;
*includeTodaysCashFlows = *QuantLibc::Settings_includeTodaysCashFlows;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Settings($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Statistics ##############

package QuantLib::Statistics;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*samples = *QuantLibc::Statistics_samples;
*weightSum = *QuantLibc::Statistics_weightSum;
*mean = *QuantLibc::Statistics_mean;
*variance = *QuantLibc::Statistics_variance;
*standardDeviation = *QuantLibc::Statistics_standardDeviation;
*errorEstimate = *QuantLibc::Statistics_errorEstimate;
*skewness = *QuantLibc::Statistics_skewness;
*kurtosis = *QuantLibc::Statistics_kurtosis;
*min = *QuantLibc::Statistics_min;
*max = *QuantLibc::Statistics_max;
*reset = *QuantLibc::Statistics_reset;
*add = *QuantLibc::Statistics_add;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Statistics(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Statistics($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::IncrementalStatistics ##############

package QuantLib::IncrementalStatistics;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*samples = *QuantLibc::IncrementalStatistics_samples;
*weightSum = *QuantLibc::IncrementalStatistics_weightSum;
*mean = *QuantLibc::IncrementalStatistics_mean;
*variance = *QuantLibc::IncrementalStatistics_variance;
*standardDeviation = *QuantLibc::IncrementalStatistics_standardDeviation;
*errorEstimate = *QuantLibc::IncrementalStatistics_errorEstimate;
*skewness = *QuantLibc::IncrementalStatistics_skewness;
*kurtosis = *QuantLibc::IncrementalStatistics_kurtosis;
*min = *QuantLibc::IncrementalStatistics_min;
*max = *QuantLibc::IncrementalStatistics_max;
*reset = *QuantLibc::IncrementalStatistics_reset;
*add = *QuantLibc::IncrementalStatistics_add;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_IncrementalStatistics(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_IncrementalStatistics($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RiskStatistics ##############

package QuantLib::RiskStatistics;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Statistics QuantLib );
%OWNER = ();
%ITERATORS = ();
*semiVariance = *QuantLibc::RiskStatistics_semiVariance;
*semiDeviation = *QuantLibc::RiskStatistics_semiDeviation;
*downsideVariance = *QuantLibc::RiskStatistics_downsideVariance;
*downsideDeviation = *QuantLibc::RiskStatistics_downsideDeviation;
*regret = *QuantLibc::RiskStatistics_regret;
*potentialUpside = *QuantLibc::RiskStatistics_potentialUpside;
*valueAtRisk = *QuantLibc::RiskStatistics_valueAtRisk;
*expectedShortfall = *QuantLibc::RiskStatistics_expectedShortfall;
*shortfall = *QuantLibc::RiskStatistics_shortfall;
*averageShortfall = *QuantLibc::RiskStatistics_averageShortfall;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RiskStatistics(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RiskStatistics($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MultipleStatistics ##############

package QuantLib::MultipleStatistics;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MultipleStatistics(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::MultipleStatistics_size;
*samples = *QuantLibc::MultipleStatistics_samples;
*weightSum = *QuantLibc::MultipleStatistics_weightSum;
*mean = *QuantLibc::MultipleStatistics_mean;
*variance = *QuantLibc::MultipleStatistics_variance;
*standardDeviation = *QuantLibc::MultipleStatistics_standardDeviation;
*errorEstimate = *QuantLibc::MultipleStatistics_errorEstimate;
*skewness = *QuantLibc::MultipleStatistics_skewness;
*kurtosis = *QuantLibc::MultipleStatistics_kurtosis;
*min = *QuantLibc::MultipleStatistics_min;
*max = *QuantLibc::MultipleStatistics_max;
*covariance = *QuantLibc::MultipleStatistics_covariance;
*correlation = *QuantLibc::MultipleStatistics_correlation;
*reset = *QuantLibc::MultipleStatistics_reset;
*add = *QuantLibc::MultipleStatistics_add;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MultipleStatistics($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::SequenceStatistics ##############

package QuantLib::SequenceStatistics;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_SequenceStatistics(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::SequenceStatistics_size;
*samples = *QuantLibc::SequenceStatistics_samples;
*weightSum = *QuantLibc::SequenceStatistics_weightSum;
*mean = *QuantLibc::SequenceStatistics_mean;
*variance = *QuantLibc::SequenceStatistics_variance;
*standardDeviation = *QuantLibc::SequenceStatistics_standardDeviation;
*errorEstimate = *QuantLibc::SequenceStatistics_errorEstimate;
*skewness = *QuantLibc::SequenceStatistics_skewness;
*kurtosis = *QuantLibc::SequenceStatistics_kurtosis;
*min = *QuantLibc::SequenceStatistics_min;
*max = *QuantLibc::SequenceStatistics_max;
*covariance = *QuantLibc::SequenceStatistics_covariance;
*correlation = *QuantLibc::SequenceStatistics_correlation;
*reset = *QuantLibc::SequenceStatistics_reset;
*add = *QuantLibc::SequenceStatistics_add;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_SequenceStatistics($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MultipleIncrementalStatistics ##############

package QuantLib::MultipleIncrementalStatistics;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MultipleIncrementalStatistics(@_);
    bless $self, $pkg if defined($self);
}

*size = *QuantLibc::MultipleIncrementalStatistics_size;
*samples = *QuantLibc::MultipleIncrementalStatistics_samples;
*weightSum = *QuantLibc::MultipleIncrementalStatistics_weightSum;
*mean = *QuantLibc::MultipleIncrementalStatistics_mean;
*variance = *QuantLibc::MultipleIncrementalStatistics_variance;
*standardDeviation = *QuantLibc::MultipleIncrementalStatistics_standardDeviation;
*errorEstimate = *QuantLibc::MultipleIncrementalStatistics_errorEstimate;
*skewness = *QuantLibc::MultipleIncrementalStatistics_skewness;
*kurtosis = *QuantLibc::MultipleIncrementalStatistics_kurtosis;
*min = *QuantLibc::MultipleIncrementalStatistics_min;
*max = *QuantLibc::MultipleIncrementalStatistics_max;
*covariance = *QuantLibc::MultipleIncrementalStatistics_covariance;
*correlation = *QuantLibc::MultipleIncrementalStatistics_correlation;
*reset = *QuantLibc::MultipleIncrementalStatistics_reset;
*add = *QuantLibc::MultipleIncrementalStatistics_add;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MultipleIncrementalStatistics($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CapFloorTermVolatilityStructure ##############

package QuantLib::CapFloorTermVolatilityStructure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::CapFloorTermVolatilityStructure___deref__;
*isNull = *QuantLibc::CapFloorTermVolatilityStructure_isNull;
*asObservable = *QuantLibc::CapFloorTermVolatilityStructure_asObservable;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CapFloorTermVolatilityStructure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CapFloorTermVolatilityStructure($self);
        delete $OWNER{$self};
    }
}

*volatility = *QuantLibc::CapFloorTermVolatilityStructure_volatility;
*enableExtrapolation = *QuantLibc::CapFloorTermVolatilityStructure_enableExtrapolation;
*disableExtrapolation = *QuantLibc::CapFloorTermVolatilityStructure_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::CapFloorTermVolatilityStructure_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CapFloorTermVolatilityStructureHandle ##############

package QuantLib::CapFloorTermVolatilityStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CapFloorTermVolatilityStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *QuantLibc::CapFloorTermVolatilityStructureHandle___deref__;
*empty = *QuantLibc::CapFloorTermVolatilityStructureHandle_empty;
*asObservable = *QuantLibc::CapFloorTermVolatilityStructureHandle_asObservable;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CapFloorTermVolatilityStructureHandle($self);
        delete $OWNER{$self};
    }
}

*volatility = *QuantLibc::CapFloorTermVolatilityStructureHandle_volatility;
*enableExtrapolation = *QuantLibc::CapFloorTermVolatilityStructureHandle_enableExtrapolation;
*disableExtrapolation = *QuantLibc::CapFloorTermVolatilityStructureHandle_disableExtrapolation;
*allowsExtrapolation = *QuantLibc::CapFloorTermVolatilityStructureHandle_allowsExtrapolation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::RelinkableCapFloorTermVolatilityStructureHandle ##############

package QuantLib::RelinkableCapFloorTermVolatilityStructureHandle;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CapFloorTermVolatilityStructureHandle QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_RelinkableCapFloorTermVolatilityStructureHandle(@_);
    bless $self, $pkg if defined($self);
}

*linkTo = *QuantLibc::RelinkableCapFloorTermVolatilityStructureHandle_linkTo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_RelinkableCapFloorTermVolatilityStructureHandle($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CapFloorTermVolCurve ##############

package QuantLib::CapFloorTermVolCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CapFloorTermVolatilityStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CapFloorTermVolCurve(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CapFloorTermVolCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CapFloorTermVolSurface ##############

package QuantLib::CapFloorTermVolSurface;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::CapFloorTermVolatilityStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CapFloorTermVolSurface(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CapFloorTermVolSurface($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::StrippedOptionletBase ##############

package QuantLib::StrippedOptionletBase;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *QuantLibc::StrippedOptionletBase___deref__;
*isNull = *QuantLibc::StrippedOptionletBase_isNull;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_StrippedOptionletBase(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_StrippedOptionletBase($self);
        delete $OWNER{$self};
    }
}

*optionletStrikes = *QuantLibc::StrippedOptionletBase_optionletStrikes;
*optionletVolatilities = *QuantLibc::StrippedOptionletBase_optionletVolatilities;
*optionletFixingDates = *QuantLibc::StrippedOptionletBase_optionletFixingDates;
*optionletFixingTimes = *QuantLibc::StrippedOptionletBase_optionletFixingTimes;
*optionletMaturities = *QuantLibc::StrippedOptionletBase_optionletMaturities;
*atmOptionletRates = *QuantLibc::StrippedOptionletBase_atmOptionletRates;
*dayCounter = *QuantLibc::StrippedOptionletBase_dayCounter;
*calendar = *QuantLibc::StrippedOptionletBase_calendar;
*settlementDays = *QuantLibc::StrippedOptionletBase_settlementDays;
*businessDayConvention = *QuantLibc::StrippedOptionletBase_businessDayConvention;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::OptionletStripper1 ##############

package QuantLib::OptionletStripper1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::StrippedOptionletBase QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_OptionletStripper1(@_);
    bless $self, $pkg if defined($self);
}

*capFloorPrices = *QuantLibc::OptionletStripper1_capFloorPrices;
*capFloorVolatilities = *QuantLibc::OptionletStripper1_capFloorVolatilities;
*optionletPrices = *QuantLibc::OptionletStripper1_optionletPrices;
*switchStrike = *QuantLibc::OptionletStripper1_switchStrike;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_OptionletStripper1($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::StrippedOptionletAdapter ##############

package QuantLib::StrippedOptionletAdapter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::OptionletVolatilityStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_StrippedOptionletAdapter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_StrippedOptionletAdapter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Settlement ##############

package QuantLib::Settlement;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
*Physical = *QuantLibc::Settlement_Physical;
*Cash = *QuantLibc::Settlement_Cash;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Settlement(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Settlement($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Swaption ##############

package QuantLib::Swaption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Swaption(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Swaption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::NonstandardSwaption ##############

package QuantLib::NonstandardSwaption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_NonstandardSwaption(@_);
    bless $self, $pkg if defined($self);
}

*calibrationBasket = *QuantLibc::NonstandardSwaption_calibrationBasket;
*underlyingSwap = *QuantLibc::NonstandardSwaption_underlyingSwap;
*probabilities = *QuantLibc::NonstandardSwaption_probabilities;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_NonstandardSwaption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FloatFloatSwaption ##############

package QuantLib::FloatFloatSwaption;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FloatFloatSwaption(@_);
    bless $self, $pkg if defined($self);
}

*calibrationBasket = *QuantLibc::FloatFloatSwaption_calibrationBasket;
*underlyingValue = *QuantLibc::FloatFloatSwaption_underlyingValue;
*underlyingSwap = *QuantLibc::FloatFloatSwaption_underlyingSwap;
*probabilities = *QuantLibc::FloatFloatSwaption_probabilities;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FloatFloatSwaption($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BlackSwaptionEngine ##############

package QuantLib::BlackSwaptionEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BlackSwaptionEngine(@_);
    bless $self, $pkg if defined($self);
}

*vega = *QuantLibc::BlackSwaptionEngine_vega;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BlackSwaptionEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BachelierSwaptionEngine ##############

package QuantLib::BachelierSwaptionEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::PricingEngine QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BachelierSwaptionEngine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BachelierSwaptionEngine($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ConstantEstimator ##############

package QuantLib::ConstantEstimator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ConstantEstimator(@_);
    bless $self, $pkg if defined($self);
}

*calculate = *QuantLibc::ConstantEstimator_calculate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ConstantEstimator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ParkinsonSigma ##############

package QuantLib::ParkinsonSigma;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ParkinsonSigma(@_);
    bless $self, $pkg if defined($self);
}

*calculate = *QuantLibc::ParkinsonSigma_calculate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ParkinsonSigma($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GarmanKlassSigma1 ##############

package QuantLib::GarmanKlassSigma1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GarmanKlassSigma1(@_);
    bless $self, $pkg if defined($self);
}

*calculate = *QuantLibc::GarmanKlassSigma1_calculate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GarmanKlassSigma1($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GarmanKlassSigma3 ##############

package QuantLib::GarmanKlassSigma3;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GarmanKlassSigma3(@_);
    bless $self, $pkg if defined($self);
}

*calculate = *QuantLibc::GarmanKlassSigma3_calculate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GarmanKlassSigma3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GarmanKlassSigma4 ##############

package QuantLib::GarmanKlassSigma4;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GarmanKlassSigma4(@_);
    bless $self, $pkg if defined($self);
}

*calculate = *QuantLibc::GarmanKlassSigma4_calculate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GarmanKlassSigma4($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GarmanKlassSigma5 ##############

package QuantLib::GarmanKlassSigma5;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GarmanKlassSigma5(@_);
    bless $self, $pkg if defined($self);
}

*calculate = *QuantLibc::GarmanKlassSigma5_calculate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GarmanKlassSigma5($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::GarmanKlassSigma6 ##############

package QuantLib::GarmanKlassSigma6;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_GarmanKlassSigma6(@_);
    bless $self, $pkg if defined($self);
}

*calculate = *QuantLibc::GarmanKlassSigma6_calculate;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_GarmanKlassSigma6($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ZeroCurve ##############

package QuantLib::ZeroCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ZeroCurve(@_);
    bless $self, $pkg if defined($self);
}

*times = *QuantLibc::ZeroCurve_times;
*data = *QuantLibc::ZeroCurve_data;
*dates = *QuantLibc::ZeroCurve_dates;
*zeroRates = *QuantLibc::ZeroCurve_zeroRates;
*nodes = *QuantLibc::ZeroCurve_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ZeroCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LogLinearZeroCurve ##############

package QuantLib::LogLinearZeroCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LogLinearZeroCurve(@_);
    bless $self, $pkg if defined($self);
}

*times = *QuantLibc::LogLinearZeroCurve_times;
*data = *QuantLibc::LogLinearZeroCurve_data;
*dates = *QuantLibc::LogLinearZeroCurve_dates;
*zeroRates = *QuantLibc::LogLinearZeroCurve_zeroRates;
*nodes = *QuantLibc::LogLinearZeroCurve_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LogLinearZeroCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::CubicZeroCurve ##############

package QuantLib::CubicZeroCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_CubicZeroCurve(@_);
    bless $self, $pkg if defined($self);
}

*times = *QuantLibc::CubicZeroCurve_times;
*data = *QuantLibc::CubicZeroCurve_data;
*dates = *QuantLibc::CubicZeroCurve_dates;
*zeroRates = *QuantLibc::CubicZeroCurve_zeroRates;
*nodes = *QuantLibc::CubicZeroCurve_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_CubicZeroCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::LogCubicZeroCurve ##############

package QuantLib::LogCubicZeroCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_LogCubicZeroCurve(@_);
    bless $self, $pkg if defined($self);
}

*times = *QuantLibc::LogCubicZeroCurve_times;
*data = *QuantLibc::LogCubicZeroCurve_data;
*dates = *QuantLibc::LogCubicZeroCurve_dates;
*zeroRates = *QuantLibc::LogCubicZeroCurve_zeroRates;
*nodes = *QuantLibc::LogCubicZeroCurve_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_LogCubicZeroCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::ForwardFlatZeroCurve ##############

package QuantLib::ForwardFlatZeroCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_ForwardFlatZeroCurve(@_);
    bless $self, $pkg if defined($self);
}

*times = *QuantLibc::ForwardFlatZeroCurve_times;
*data = *QuantLibc::ForwardFlatZeroCurve_data;
*dates = *QuantLibc::ForwardFlatZeroCurve_dates;
*zeroRates = *QuantLibc::ForwardFlatZeroCurve_zeroRates;
*nodes = *QuantLibc::ForwardFlatZeroCurve_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_ForwardFlatZeroCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::BackwardFlatZeroCurve ##############

package QuantLib::BackwardFlatZeroCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_BackwardFlatZeroCurve(@_);
    bless $self, $pkg if defined($self);
}

*times = *QuantLibc::BackwardFlatZeroCurve_times;
*data = *QuantLibc::BackwardFlatZeroCurve_data;
*dates = *QuantLibc::BackwardFlatZeroCurve_dates;
*zeroRates = *QuantLibc::BackwardFlatZeroCurve_zeroRates;
*nodes = *QuantLibc::BackwardFlatZeroCurve_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_BackwardFlatZeroCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::MonotonicCubicZeroCurve ##############

package QuantLib::MonotonicCubicZeroCurve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::YieldTermStructure QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_MonotonicCubicZeroCurve(@_);
    bless $self, $pkg if defined($self);
}

*times = *QuantLibc::MonotonicCubicZeroCurve_times;
*data = *QuantLibc::MonotonicCubicZeroCurve_data;
*dates = *QuantLibc::MonotonicCubicZeroCurve_dates;
*zeroRates = *QuantLibc::MonotonicCubicZeroCurve_zeroRates;
*nodes = *QuantLibc::MonotonicCubicZeroCurve_nodes;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_MonotonicCubicZeroCurve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::Forward ##############

package QuantLib::Forward;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Instrument QuantLib );
%OWNER = ();
%ITERATORS = ();
*forwardValue = *QuantLibc::Forward_forwardValue;
*impliedYield = *QuantLibc::Forward_impliedYield;
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_Forward(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_Forward($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : QuantLib::FixedRateBondForward ##############

package QuantLib::FixedRateBondForward;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( QuantLib::Forward QuantLib );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = QuantLibc::new_FixedRateBondForward(@_);
    bless $self, $pkg if defined($self);
}

*forwardPrice = *QuantLibc::FixedRateBondForward_forwardPrice;
*cleanForwardPrice = *QuantLibc::FixedRateBondForward_cleanForwardPrice;
*spotIncome = *QuantLibc::FixedRateBondForward_spotIncome;
*spotValue = *QuantLibc::FixedRateBondForward_spotValue;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        QuantLibc::delete_FixedRateBondForward($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package QuantLib;

*Sunday = *QuantLibc::Sunday;
*Monday = *QuantLibc::Monday;
*Tuesday = *QuantLibc::Tuesday;
*Wednesday = *QuantLibc::Wednesday;
*Thursday = *QuantLibc::Thursday;
*Friday = *QuantLibc::Friday;
*Saturday = *QuantLibc::Saturday;
*January = *QuantLibc::January;
*February = *QuantLibc::February;
*March = *QuantLibc::March;
*April = *QuantLibc::April;
*May = *QuantLibc::May;
*June = *QuantLibc::June;
*July = *QuantLibc::July;
*August = *QuantLibc::August;
*September = *QuantLibc::September;
*October = *QuantLibc::October;
*November = *QuantLibc::November;
*December = *QuantLibc::December;
*Days = *QuantLibc::Days;
*Weeks = *QuantLibc::Weeks;
*Months = *QuantLibc::Months;
*Years = *QuantLibc::Years;
*Hours = *QuantLibc::Hours;
*Minutes = *QuantLibc::Minutes;
*Seconds = *QuantLibc::Seconds;
*Milliseconds = *QuantLibc::Milliseconds;
*Microseconds = *QuantLibc::Microseconds;
*NoFrequency = *QuantLibc::NoFrequency;
*Once = *QuantLibc::Once;
*Annual = *QuantLibc::Annual;
*Semiannual = *QuantLibc::Semiannual;
*EveryFourthMonth = *QuantLibc::EveryFourthMonth;
*Quarterly = *QuantLibc::Quarterly;
*Bimonthly = *QuantLibc::Bimonthly;
*Monthly = *QuantLibc::Monthly;
*EveryFourthWeek = *QuantLibc::EveryFourthWeek;
*Biweekly = *QuantLibc::Biweekly;
*Weekly = *QuantLibc::Weekly;
*Daily = *QuantLibc::Daily;
*OtherFrequency = *QuantLibc::OtherFrequency;
*Following = *QuantLibc::Following;
*ModifiedFollowing = *QuantLibc::ModifiedFollowing;
*Preceding = *QuantLibc::Preceding;
*ModifiedPreceding = *QuantLibc::ModifiedPreceding;
*Unadjusted = *QuantLibc::Unadjusted;
*HalfMonthModifiedFollowing = *QuantLibc::HalfMonthModifiedFollowing;
*JoinHolidays = *QuantLibc::JoinHolidays;
*JoinBusinessDays = *QuantLibc::JoinBusinessDays;
*Simple = *QuantLibc::Simple;
*Compounded = *QuantLibc::Compounded;
*Continuous = *QuantLibc::Continuous;
*SimpleThenCompounded = *QuantLibc::SimpleThenCompounded;
*CompoundedThenSimple = *QuantLibc::CompoundedThenSimple;
*ShiftedLognormal = *QuantLibc::ShiftedLognormal;
*Normal = *QuantLibc::Normal;
1;
